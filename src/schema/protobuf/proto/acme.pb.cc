// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acme.proto

#include "acme.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace A0S_proto {
template <typename>
PROTOBUF_CONSTEXPR PbSdlRect::PbSdlRect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.w_)*/ 0

  , /*decltype(_impl_.h_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PbSdlRectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbSdlRectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbSdlRectDefaultTypeInternal() {}
  union {
    PbSdlRect _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbSdlRectDefaultTypeInternal _PbSdlRect_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbSdlPoint::PbSdlPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PbSdlPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbSdlPointDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbSdlPointDefaultTypeInternal() {}
  union {
    PbSdlPoint _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbSdlPointDefaultTypeInternal _PbSdlPoint_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbObject::PbObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.collision_rect_)*/nullptr
  , /*decltype(_impl_.dest_rect_)*/nullptr
  , /*decltype(_impl_.src_rect_)*/nullptr
  , /*decltype(_impl_.frame_display_time_)*/ 0u

  , /*decltype(_impl_.current_frame_)*/ 0

  , /*decltype(_impl_.to_erase_)*/ false

  , /*decltype(_impl_.type_)*/ 0

  , /*decltype(_impl_.pos_x_)*/ 0

  , /*decltype(_impl_.pos_y_)*/ 0
} {}
struct PbObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbObjectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbObjectDefaultTypeInternal() {}
  union {
    PbObject _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbObjectDefaultTypeInternal _PbObject_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbBullet::PbBullet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.speed_)*/ 0

  , /*decltype(_impl_.collide_)*/ false

  , /*decltype(_impl_.increased_damage_)*/ false

  , /*decltype(_impl_.direction_)*/ 0
} {}
struct PbBulletDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbBulletDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbBulletDefaultTypeInternal() {}
  union {
    PbBullet _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbBulletDefaultTypeInternal _PbBullet_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbBonus::PbBonus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.bonus_show_time_)*/ 0u

  , /*decltype(_impl_.show_)*/ false
} {}
struct PbBonusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbBonusDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbBonusDefaultTypeInternal() {}
  union {
    PbBonus _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbBonusDefaultTypeInternal _PbBonus_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbBrick::PbBrick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.collision_count_)*/ 0

  , /*decltype(_impl_.state_code_)*/ 0
} {}
struct PbBrickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbBrickDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbBrickDefaultTypeInternal() {}
  union {
    PbBrick _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbBrickDefaultTypeInternal _PbBrick_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbTank::PbTank(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bullets_)*/{}
  , /*decltype(_impl_.object_)*/nullptr
  , /*decltype(_impl_.flags_)*/ 0

  , /*decltype(_impl_.slip_time_)*/ 0

  , /*decltype(_impl_.new_direction_)*/ 0

  , /*decltype(_impl_.bullet_max_size_)*/ 0u

  , /*decltype(_impl_.shield_time_)*/ 0u

  , /*decltype(_impl_.frozen_time_)*/ 0u

  , /*decltype(_impl_.default_speed_)*/ 0

  , /*decltype(_impl_.speed_)*/ 0

  , /*decltype(_impl_.stop_)*/ false

  , /*decltype(_impl_.direction_)*/ 0

  , /*decltype(_impl_.lives_count_)*/ 0
} {}
struct PbTankDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbTankDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbTankDefaultTypeInternal() {}
  union {
    PbTank _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbTankDefaultTypeInternal _PbTank_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbPlayer::PbPlayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tank_)*/nullptr
  , /*decltype(_impl_.star_count_)*/ 0

  , /*decltype(_impl_.fire_time_)*/ 0u

  , /*decltype(_impl_.movement_)*/ false

  , /*decltype(_impl_.menu_)*/ false
} {}
struct PbPlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbPlayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbPlayerDefaultTypeInternal() {}
  union {
    PbPlayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbPlayerDefaultTypeInternal _PbPlayer_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PbEnemy::PbEnemy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tank_)*/nullptr
  , /*decltype(_impl_.target_position_)*/nullptr
  , /*decltype(_impl_.direction_time_)*/ 0u

  , /*decltype(_impl_.keep_direction_time_)*/ 0u

  , /*decltype(_impl_.speed_time_)*/ 0u

  , /*decltype(_impl_.try_to_go_time_)*/ 0u

  , /*decltype(_impl_.fire_time_)*/ 0u

  , /*decltype(_impl_.reload_time_)*/ 0u
} {}
struct PbEnemyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PbEnemyDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PbEnemyDefaultTypeInternal() {}
  union {
    PbEnemy _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PbEnemyDefaultTypeInternal _PbEnemy_default_instance_;
}  // namespace A0S_proto
static ::_pb::Metadata file_level_metadata_acme_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_acme_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_acme_2eproto = nullptr;
const ::uint32_t TableStruct_acme_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlRect, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlRect, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlRect, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlRect, _impl_.w_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlRect, _impl_.h_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlPoint, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlPoint, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbSdlPoint, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.frame_display_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.current_frame_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.to_erase_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.collision_rect_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.dest_rect_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.src_rect_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.pos_x_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbObject, _impl_.pos_y_),
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    2,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_.object_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_.speed_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_.collide_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_.increased_damage_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBullet, _impl_.direction_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBonus, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBonus, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBonus, _impl_.object_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBonus, _impl_.bonus_show_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBonus, _impl_.show_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBrick, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBrick, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBrick, _impl_.object_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBrick, _impl_.collision_count_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbBrick, _impl_.state_code_),
    0,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.object_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.flags_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.slip_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.new_direction_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.bullet_max_size_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.shield_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.frozen_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.default_speed_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.speed_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.stop_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.direction_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.bullets_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbTank, _impl_.lives_count_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_.tank_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_.star_count_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_.fire_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_.movement_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbPlayer, _impl_.menu_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.tank_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.direction_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.keep_direction_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.speed_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.try_to_go_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.fire_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.reload_time_),
    PROTOBUF_FIELD_OFFSET(::A0S_proto::PbEnemy, _impl_.target_position_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, -1, -1, sizeof(::A0S_proto::PbSdlRect)},
        { 12, -1, -1, sizeof(::A0S_proto::PbSdlPoint)},
        { 22, 39, -1, sizeof(::A0S_proto::PbObject)},
        { 48, 61, -1, sizeof(::A0S_proto::PbBullet)},
        { 66, 77, -1, sizeof(::A0S_proto::PbBonus)},
        { 80, 91, -1, sizeof(::A0S_proto::PbBrick)},
        { 94, 115, -1, sizeof(::A0S_proto::PbTank)},
        { 128, 141, -1, sizeof(::A0S_proto::PbPlayer)},
        { 146, 162, -1, sizeof(::A0S_proto::PbEnemy)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::A0S_proto::_PbSdlRect_default_instance_._instance,
    &::A0S_proto::_PbSdlPoint_default_instance_._instance,
    &::A0S_proto::_PbObject_default_instance_._instance,
    &::A0S_proto::_PbBullet_default_instance_._instance,
    &::A0S_proto::_PbBonus_default_instance_._instance,
    &::A0S_proto::_PbBrick_default_instance_._instance,
    &::A0S_proto::_PbTank_default_instance_._instance,
    &::A0S_proto::_PbPlayer_default_instance_._instance,
    &::A0S_proto::_PbEnemy_default_instance_._instance,
};
const char descriptor_table_protodef_acme_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\nacme.proto\022\tA0S_proto\"7\n\tPbSdlRect\022\t\n\001"
    "x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\022\t\n\001w\030\003 \001(\005\022\t\n\001h\030\005 \001(\005"
    "\"\"\n\nPbSdlPoint\022\t\n\001x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\"\223\002\n"
    "\010PbObject\022\032\n\022frame_display_time\030\001 \001(\r\022\025\n"
    "\rcurrent_frame\030\002 \001(\005\022\020\n\010to_erase\030\003 \001(\010\022,"
    "\n\016collision_rect\030\004 \001(\0132\024.A0S_proto.PbSdl"
    "Rect\022\'\n\tdest_rect\030\005 \001(\0132\024.A0S_proto.PbSd"
    "lRect\022&\n\010src_rect\030\006 \001(\0132\024.A0S_proto.PbSd"
    "lRect\022%\n\004type\030\007 \001(\0162\027.A0S_proto.PbSprite"
    "Type\022\r\n\005pos_x\030\010 \001(\001\022\r\n\005pos_y\030\t \001(\001\"\224\001\n\010P"
    "bBullet\022#\n\006object\030\001 \001(\0132\023.A0S_proto.PbOb"
    "ject\022\r\n\005speed\030\002 \001(\001\022\017\n\007collide\030\003 \001(\010\022\030\n\020"
    "increased_damage\030\004 \001(\010\022)\n\tdirection\030\005 \001("
    "\0162\026.A0S_proto.PbDirection\"U\n\007PbBonus\022#\n\006"
    "object\030\001 \001(\0132\023.A0S_proto.PbObject\022\027\n\017bon"
    "us_show_time\030\002 \001(\r\022\014\n\004show\030\003 \001(\010\"[\n\007PbBr"
    "ick\022#\n\006object\030\001 \001(\0132\023.A0S_proto.PbObject"
    "\022\027\n\017collision_count\030\002 \001(\005\022\022\n\nstate_code\030"
    "\003 \001(\005\"\367\002\n\006PbTank\022#\n\006object\030\001 \001(\0132\023.A0S_p"
    "roto.PbObject\022)\n\005flags\030\002 \001(\0162\032.A0S_proto"
    ".PbTankStateFlag\022\021\n\tslip_time\030\003 \001(\021\022-\n\rn"
    "ew_direction\030\004 \001(\0162\026.A0S_proto.PbDirecti"
    "on\022\027\n\017bullet_max_size\030\005 \001(\r\022\023\n\013shield_ti"
    "me\030\006 \001(\r\022\023\n\013frozen_time\030\007 \001(\r\022\025\n\rdefault"
    "_speed\030\010 \001(\001\022\r\n\005speed\030\t \001(\001\022\014\n\004stop\030\n \001("
    "\010\022)\n\tdirection\030\013 \001(\0162\026.A0S_proto.PbDirec"
    "tion\022$\n\007bullets\030\014 \003(\0132\023.A0S_proto.PbBull"
    "et\022\023\n\013lives_count\030\r \001(\005\"r\n\010PbPlayer\022\037\n\004t"
    "ank\030\001 \001(\0132\021.A0S_proto.PbTank\022\022\n\nstar_cou"
    "nt\030\002 \001(\005\022\021\n\tfire_time\030\003 \001(\r\022\020\n\010movement\030"
    "\004 \001(\010\022\014\n\004menu\030\005 \001(\010\"\343\001\n\007PbEnemy\022\037\n\004tank\030"
    "\001 \001(\0132\021.A0S_proto.PbTank\022\026\n\016direction_ti"
    "me\030\002 \001(\r\022\033\n\023keep_direction_time\030\003 \001(\r\022\022\n"
    "\nspeed_time\030\004 \001(\r\022\026\n\016try_to_go_time\030\005 \001("
    "\r\022\021\n\tfire_time\030\006 \001(\r\022\023\n\013reload_time\030\007 \001("
    "\r\022.\n\017target_position\030\010 \001(\0132\025.A0S_proto.P"
    "bSdlPoint*\312\004\n\014PbSpriteType\022\r\n\tST_TANK_A\020"
    "\000\022\r\n\tST_TANK_B\020\001\022\r\n\tST_TANK_C\020\002\022\r\n\tST_TA"
    "NK_D\020\003\022\017\n\013ST_PLAYER_1\020\004\022\017\n\013ST_PLAYER_2\020\005"
    "\022\021\n\rST_BRICK_WALL\020\006\022\021\n\rST_STONE_WALL\020\007\022\014"
    "\n\010ST_WATER\020\010\022\013\n\007ST_BUSH\020\t\022\n\n\006ST_ICE\020\n\022\024\n"
    "\020ST_BONUS_GRENADE\020\013\022\023\n\017ST_BONUS_HELMET\020\014"
    "\022\022\n\016ST_BONUS_CLOCK\020\r\022\023\n\017ST_BONUS_SHOVEL\020"
    "\016\022\021\n\rST_BONUS_TANK\020\017\022\021\n\rST_BONUS_STAR\020\020\022"
    "\020\n\014ST_BONUS_GUN\020\021\022\021\n\rST_BONUS_BOAT\020\022\022\r\n\t"
    "ST_SHIELD\020\023\022\r\n\tST_CREATE\020\024\022\023\n\017ST_DESTROY"
    "_TANK\020\025\022\025\n\021ST_DESTROY_BULLET\020\026\022\016\n\nST_BOA"
    "T_P1\020\027\022\016\n\nST_BOAT_P2\020\030\022\014\n\010ST_EAGLE\020\031\022\024\n\020"
    "ST_DESTROY_EAGLE\020\032\022\013\n\007ST_FLAG\020\033\022\r\n\tST_BU"
    "LLET\020\034\022\021\n\rST_LEFT_ENEMY\020\035\022\023\n\017ST_STAGE_ST"
    "ATUS\020\036\022\021\n\rST_TANKS_LOGO\020\037\022\013\n\007ST_NONE\020 *\256"
    "\001\n\017PbTankStateFlag\022\017\n\013TSF_DEFAULT\020\000\022\016\n\nT"
    "SF_SHIELD\020\001\022\016\n\nTSF_FROZEN\020\002\022\021\n\rTSF_DESTR"
    "OYED\020\003\022\014\n\010TSF_BOAT\020\004\022\r\n\tTSF_BONUS\020\005\022\016\n\nT"
    "SF_ON_ICE\020\006\022\016\n\nTSF_CREATE\020\007\022\014\n\010TSF_LIFE\020"
    "\010\022\014\n\010TSF_MENU\020\t*<\n\013PbDirection\022\010\n\004D_UP\020\000"
    "\022\013\n\007D_RIGHT\020\001\022\n\n\006D_DOWN\020\002\022\n\n\006D_LEFT\020\003b\006p"
    "roto3"
};
static ::absl::once_flag descriptor_table_acme_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_acme_2eproto = {
    false,
    false,
    2285,
    descriptor_table_protodef_acme_2eproto,
    "acme.proto",
    &descriptor_table_acme_2eproto_once,
    nullptr,
    0,
    9,
    schemas,
    file_default_instances,
    TableStruct_acme_2eproto::offsets,
    file_level_metadata_acme_2eproto,
    file_level_enum_descriptors_acme_2eproto,
    file_level_service_descriptors_acme_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_acme_2eproto_getter() {
  return &descriptor_table_acme_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_acme_2eproto(&descriptor_table_acme_2eproto);
namespace A0S_proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PbSpriteType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_acme_2eproto);
  return file_level_enum_descriptors_acme_2eproto[0];
}
bool PbSpriteType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PbTankStateFlag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_acme_2eproto);
  return file_level_enum_descriptors_acme_2eproto[1];
}
bool PbTankStateFlag_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PbDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_acme_2eproto);
  return file_level_enum_descriptors_acme_2eproto[2];
}
bool PbDirection_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class PbSdlRect::_Internal {
 public:
};

PbSdlRect::PbSdlRect(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbSdlRect)
}
PbSdlRect::PbSdlRect(const PbSdlRect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbSdlRect)
}

inline void PbSdlRect::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.w_) { 0 }

    , decltype(_impl_.h_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PbSdlRect::~PbSdlRect() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbSdlRect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbSdlRect::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PbSdlRect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbSdlRect::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbSdlRect)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.h_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.h_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbSdlRect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 w = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 h = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.h_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbSdlRect::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbSdlRect)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_y(), target);
  }

  // int32 w = 3;
  if (this->_internal_w() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_w(), target);
  }

  // int32 h = 5;
  if (this->_internal_h() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_h(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbSdlRect)
  return target;
}

::size_t PbSdlRect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbSdlRect)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_y());
  }

  // int32 w = 3;
  if (this->_internal_w() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_w());
  }

  // int32 h = 5;
  if (this->_internal_h() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_h());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbSdlRect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbSdlRect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbSdlRect::GetClassData() const { return &_class_data_; }


void PbSdlRect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbSdlRect*>(&to_msg);
  auto& from = static_cast<const PbSdlRect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbSdlRect)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_w() != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  if (from._internal_h() != 0) {
    _this->_internal_set_h(from._internal_h());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbSdlRect::CopyFrom(const PbSdlRect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbSdlRect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbSdlRect::IsInitialized() const {
  return true;
}

void PbSdlRect::InternalSwap(PbSdlRect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbSdlRect, _impl_.h_)
      + sizeof(PbSdlRect::_impl_.h_)
      - PROTOBUF_FIELD_OFFSET(PbSdlRect, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbSdlRect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[0]);
}
// ===================================================================

class PbSdlPoint::_Internal {
 public:
};

PbSdlPoint::PbSdlPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbSdlPoint)
}
PbSdlPoint::PbSdlPoint(const PbSdlPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbSdlPoint)
}

inline void PbSdlPoint::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PbSdlPoint::~PbSdlPoint() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbSdlPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbSdlPoint::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PbSdlPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbSdlPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbSdlPoint)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbSdlPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbSdlPoint::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbSdlPoint)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_x(), target);
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbSdlPoint)
  return target;
}

::size_t PbSdlPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbSdlPoint)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_x());
  }

  // int32 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_y());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbSdlPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbSdlPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbSdlPoint::GetClassData() const { return &_class_data_; }


void PbSdlPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbSdlPoint*>(&to_msg);
  auto& from = static_cast<const PbSdlPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbSdlPoint)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbSdlPoint::CopyFrom(const PbSdlPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbSdlPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbSdlPoint::IsInitialized() const {
  return true;
}

void PbSdlPoint::InternalSwap(PbSdlPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbSdlPoint, _impl_.y_)
      + sizeof(PbSdlPoint::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PbSdlPoint, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbSdlPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[1]);
}
// ===================================================================

class PbObject::_Internal {
 public:
  using HasBits = decltype(std::declval<PbObject>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbObject, _impl_._has_bits_);
  static const ::A0S_proto::PbSdlRect& collision_rect(const PbObject* msg);
  static void set_has_collision_rect(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::A0S_proto::PbSdlRect& dest_rect(const PbObject* msg);
  static void set_has_dest_rect(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::A0S_proto::PbSdlRect& src_rect(const PbObject* msg);
  static void set_has_src_rect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::A0S_proto::PbSdlRect&
PbObject::_Internal::collision_rect(const PbObject* msg) {
  return *msg->_impl_.collision_rect_;
}
const ::A0S_proto::PbSdlRect&
PbObject::_Internal::dest_rect(const PbObject* msg) {
  return *msg->_impl_.dest_rect_;
}
const ::A0S_proto::PbSdlRect&
PbObject::_Internal::src_rect(const PbObject* msg) {
  return *msg->_impl_.src_rect_;
}
PbObject::PbObject(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbObject)
}
PbObject::PbObject(const PbObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.collision_rect_){nullptr}
    , decltype(_impl_.dest_rect_){nullptr}
    , decltype(_impl_.src_rect_){nullptr}
    , decltype(_impl_.frame_display_time_) {}

    , decltype(_impl_.current_frame_) {}

    , decltype(_impl_.to_erase_) {}

    , decltype(_impl_.type_) {}

    , decltype(_impl_.pos_x_) {}

    , decltype(_impl_.pos_y_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.collision_rect_ = new ::A0S_proto::PbSdlRect(*from._impl_.collision_rect_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.dest_rect_ = new ::A0S_proto::PbSdlRect(*from._impl_.dest_rect_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.src_rect_ = new ::A0S_proto::PbSdlRect(*from._impl_.src_rect_);
  }
  ::memcpy(&_impl_.frame_display_time_, &from._impl_.frame_display_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.pos_y_) -
    reinterpret_cast<char*>(&_impl_.frame_display_time_)) + sizeof(_impl_.pos_y_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbObject)
}

inline void PbObject::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.collision_rect_){nullptr}
    , decltype(_impl_.dest_rect_){nullptr}
    , decltype(_impl_.src_rect_){nullptr}
    , decltype(_impl_.frame_display_time_) { 0u }

    , decltype(_impl_.current_frame_) { 0 }

    , decltype(_impl_.to_erase_) { false }

    , decltype(_impl_.type_) { 0 }

    , decltype(_impl_.pos_x_) { 0 }

    , decltype(_impl_.pos_y_) { 0 }

  };
}

PbObject::~PbObject() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbObject::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.collision_rect_;
  if (this != internal_default_instance()) delete _impl_.dest_rect_;
  if (this != internal_default_instance()) delete _impl_.src_rect_;
}

void PbObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbObject::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbObject)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.collision_rect_ != nullptr);
      _impl_.collision_rect_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.dest_rect_ != nullptr);
      _impl_.dest_rect_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.src_rect_ != nullptr);
      _impl_.src_rect_->Clear();
    }
  }
  ::memset(&_impl_.frame_display_time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.pos_y_) -
      reinterpret_cast<char*>(&_impl_.frame_display_time_)) + sizeof(_impl_.pos_y_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 frame_display_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _impl_.frame_display_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 current_frame = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.current_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool to_erase = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.to_erase_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbSdlRect collision_rect = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_collision_rect(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbSdlRect dest_rect = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_dest_rect(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbSdlRect src_rect = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_src_rect(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbSpriteType type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::A0S_proto::PbSpriteType>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // double pos_x = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _impl_.pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double pos_y = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _impl_.pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbObject::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbObject)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 frame_display_time = 1;
  if (this->_internal_frame_display_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_frame_display_time(), target);
  }

  // int32 current_frame = 2;
  if (this->_internal_current_frame() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_current_frame(), target);
  }

  // bool to_erase = 3;
  if (this->_internal_to_erase() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_to_erase(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbSdlRect collision_rect = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::collision_rect(this),
        _Internal::collision_rect(this).GetCachedSize(), target, stream);
  }

  // .A0S_proto.PbSdlRect dest_rect = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::dest_rect(this),
        _Internal::dest_rect(this).GetCachedSize(), target, stream);
  }

  // .A0S_proto.PbSdlRect src_rect = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::src_rect(this),
        _Internal::src_rect(this).GetCachedSize(), target, stream);
  }

  // .A0S_proto.PbSpriteType type = 7;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_type(), target);
  }

  // double pos_x = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_x = this->_internal_pos_x();
  ::uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_pos_x(), target);
  }

  // double pos_y = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_y = this->_internal_pos_y();
  ::uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_pos_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbObject)
  return target;
}

::size_t PbObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbObject)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // .A0S_proto.PbSdlRect collision_rect = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.collision_rect_);
    }

    // .A0S_proto.PbSdlRect dest_rect = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dest_rect_);
    }

    // .A0S_proto.PbSdlRect src_rect = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.src_rect_);
    }

  }
  // uint32 frame_display_time = 1;
  if (this->_internal_frame_display_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_frame_display_time());
  }

  // int32 current_frame = 2;
  if (this->_internal_current_frame() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_current_frame());
  }

  // bool to_erase = 3;
  if (this->_internal_to_erase() != 0) {
    total_size += 2;
  }

  // .A0S_proto.PbSpriteType type = 7;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // double pos_x = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_x = this->_internal_pos_x();
  ::uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    total_size += 9;
  }

  // double pos_y = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_y = this->_internal_pos_y();
  ::uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbObject::GetClassData() const { return &_class_data_; }


void PbObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbObject*>(&to_msg);
  auto& from = static_cast<const PbObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbObject)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_collision_rect()->::A0S_proto::PbSdlRect::MergeFrom(
          from._internal_collision_rect());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dest_rect()->::A0S_proto::PbSdlRect::MergeFrom(
          from._internal_dest_rect());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_src_rect()->::A0S_proto::PbSdlRect::MergeFrom(
          from._internal_src_rect());
    }
  }
  if (from._internal_frame_display_time() != 0) {
    _this->_internal_set_frame_display_time(from._internal_frame_display_time());
  }
  if (from._internal_current_frame() != 0) {
    _this->_internal_set_current_frame(from._internal_current_frame());
  }
  if (from._internal_to_erase() != 0) {
    _this->_internal_set_to_erase(from._internal_to_erase());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_x = from._internal_pos_x();
  ::uint64_t raw_pos_x;
  memcpy(&raw_pos_x, &tmp_pos_x, sizeof(tmp_pos_x));
  if (raw_pos_x != 0) {
    _this->_internal_set_pos_x(from._internal_pos_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_pos_y = from._internal_pos_y();
  ::uint64_t raw_pos_y;
  memcpy(&raw_pos_y, &tmp_pos_y, sizeof(tmp_pos_y));
  if (raw_pos_y != 0) {
    _this->_internal_set_pos_y(from._internal_pos_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbObject::CopyFrom(const PbObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbObject::IsInitialized() const {
  return true;
}

void PbObject::InternalSwap(PbObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbObject, _impl_.pos_y_)
      + sizeof(PbObject::_impl_.pos_y_)
      - PROTOBUF_FIELD_OFFSET(PbObject, _impl_.collision_rect_)>(
          reinterpret_cast<char*>(&_impl_.collision_rect_),
          reinterpret_cast<char*>(&other->_impl_.collision_rect_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[2]);
}
// ===================================================================

class PbBullet::_Internal {
 public:
  using HasBits = decltype(std::declval<PbBullet>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbBullet, _impl_._has_bits_);
  static const ::A0S_proto::PbObject& object(const PbBullet* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::A0S_proto::PbObject&
PbBullet::_Internal::object(const PbBullet* msg) {
  return *msg->_impl_.object_;
}
PbBullet::PbBullet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbBullet)
}
PbBullet::PbBullet(const PbBullet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbBullet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.speed_) {}

    , decltype(_impl_.collide_) {}

    , decltype(_impl_.increased_damage_) {}

    , decltype(_impl_.direction_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.object_ = new ::A0S_proto::PbObject(*from._impl_.object_);
  }
  ::memcpy(&_impl_.speed_, &from._impl_.speed_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.direction_) -
    reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.direction_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbBullet)
}

inline void PbBullet::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.speed_) { 0 }

    , decltype(_impl_.collide_) { false }

    , decltype(_impl_.increased_damage_) { false }

    , decltype(_impl_.direction_) { 0 }

  };
}

PbBullet::~PbBullet() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbBullet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbBullet::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_;
}

void PbBullet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbBullet::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbBullet)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.object_ != nullptr);
    _impl_.object_->Clear();
  }
  ::memset(&_impl_.speed_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.direction_) -
      reinterpret_cast<char*>(&_impl_.speed_)) + sizeof(_impl_.direction_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbBullet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbObject object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool collide = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.collide_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool increased_damage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.increased_damage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbDirection direction = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_direction(static_cast<::A0S_proto::PbDirection>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbBullet::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbBullet)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbObject object = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // double speed = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_speed(), target);
  }

  // bool collide = 3;
  if (this->_internal_collide() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_collide(), target);
  }

  // bool increased_damage = 4;
  if (this->_internal_increased_damage() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_increased_damage(), target);
  }

  // .A0S_proto.PbDirection direction = 5;
  if (this->_internal_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbBullet)
  return target;
}

::size_t PbBullet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbBullet)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .A0S_proto.PbObject object = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_);
  }

  // double speed = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 9;
  }

  // bool collide = 3;
  if (this->_internal_collide() != 0) {
    total_size += 2;
  }

  // bool increased_damage = 4;
  if (this->_internal_increased_damage() != 0) {
    total_size += 2;
  }

  // .A0S_proto.PbDirection direction = 5;
  if (this->_internal_direction() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbBullet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbBullet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbBullet::GetClassData() const { return &_class_data_; }


void PbBullet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbBullet*>(&to_msg);
  auto& from = static_cast<const PbBullet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbBullet)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_object()->::A0S_proto::PbObject::MergeFrom(
        from._internal_object());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_collide() != 0) {
    _this->_internal_set_collide(from._internal_collide());
  }
  if (from._internal_increased_damage() != 0) {
    _this->_internal_set_increased_damage(from._internal_increased_damage());
  }
  if (from._internal_direction() != 0) {
    _this->_internal_set_direction(from._internal_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbBullet::CopyFrom(const PbBullet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbBullet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbBullet::IsInitialized() const {
  return true;
}

void PbBullet::InternalSwap(PbBullet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbBullet, _impl_.direction_)
      + sizeof(PbBullet::_impl_.direction_)
      - PROTOBUF_FIELD_OFFSET(PbBullet, _impl_.object_)>(
          reinterpret_cast<char*>(&_impl_.object_),
          reinterpret_cast<char*>(&other->_impl_.object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbBullet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[3]);
}
// ===================================================================

class PbBonus::_Internal {
 public:
  using HasBits = decltype(std::declval<PbBonus>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbBonus, _impl_._has_bits_);
  static const ::A0S_proto::PbObject& object(const PbBonus* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::A0S_proto::PbObject&
PbBonus::_Internal::object(const PbBonus* msg) {
  return *msg->_impl_.object_;
}
PbBonus::PbBonus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbBonus)
}
PbBonus::PbBonus(const PbBonus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbBonus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.bonus_show_time_) {}

    , decltype(_impl_.show_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.object_ = new ::A0S_proto::PbObject(*from._impl_.object_);
  }
  ::memcpy(&_impl_.bonus_show_time_, &from._impl_.bonus_show_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.show_) -
    reinterpret_cast<char*>(&_impl_.bonus_show_time_)) + sizeof(_impl_.show_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbBonus)
}

inline void PbBonus::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.bonus_show_time_) { 0u }

    , decltype(_impl_.show_) { false }

  };
}

PbBonus::~PbBonus() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbBonus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbBonus::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_;
}

void PbBonus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbBonus::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbBonus)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.object_ != nullptr);
    _impl_.object_->Clear();
  }
  ::memset(&_impl_.bonus_show_time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.show_) -
      reinterpret_cast<char*>(&_impl_.bonus_show_time_)) + sizeof(_impl_.show_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbBonus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbObject object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 bonus_show_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.bonus_show_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool show = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.show_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbBonus::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbBonus)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbObject object = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // uint32 bonus_show_time = 2;
  if (this->_internal_bonus_show_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_bonus_show_time(), target);
  }

  // bool show = 3;
  if (this->_internal_show() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_show(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbBonus)
  return target;
}

::size_t PbBonus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbBonus)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .A0S_proto.PbObject object = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_);
  }

  // uint32 bonus_show_time = 2;
  if (this->_internal_bonus_show_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_bonus_show_time());
  }

  // bool show = 3;
  if (this->_internal_show() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbBonus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbBonus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbBonus::GetClassData() const { return &_class_data_; }


void PbBonus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbBonus*>(&to_msg);
  auto& from = static_cast<const PbBonus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbBonus)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_object()->::A0S_proto::PbObject::MergeFrom(
        from._internal_object());
  }
  if (from._internal_bonus_show_time() != 0) {
    _this->_internal_set_bonus_show_time(from._internal_bonus_show_time());
  }
  if (from._internal_show() != 0) {
    _this->_internal_set_show(from._internal_show());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbBonus::CopyFrom(const PbBonus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbBonus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbBonus::IsInitialized() const {
  return true;
}

void PbBonus::InternalSwap(PbBonus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbBonus, _impl_.show_)
      + sizeof(PbBonus::_impl_.show_)
      - PROTOBUF_FIELD_OFFSET(PbBonus, _impl_.object_)>(
          reinterpret_cast<char*>(&_impl_.object_),
          reinterpret_cast<char*>(&other->_impl_.object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbBonus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[4]);
}
// ===================================================================

class PbBrick::_Internal {
 public:
  using HasBits = decltype(std::declval<PbBrick>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbBrick, _impl_._has_bits_);
  static const ::A0S_proto::PbObject& object(const PbBrick* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::A0S_proto::PbObject&
PbBrick::_Internal::object(const PbBrick* msg) {
  return *msg->_impl_.object_;
}
PbBrick::PbBrick(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbBrick)
}
PbBrick::PbBrick(const PbBrick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbBrick* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.collision_count_) {}

    , decltype(_impl_.state_code_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.object_ = new ::A0S_proto::PbObject(*from._impl_.object_);
  }
  ::memcpy(&_impl_.collision_count_, &from._impl_.collision_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.state_code_) -
    reinterpret_cast<char*>(&_impl_.collision_count_)) + sizeof(_impl_.state_code_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbBrick)
}

inline void PbBrick::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.collision_count_) { 0 }

    , decltype(_impl_.state_code_) { 0 }

  };
}

PbBrick::~PbBrick() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbBrick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbBrick::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.object_;
}

void PbBrick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbBrick::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbBrick)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.object_ != nullptr);
    _impl_.object_->Clear();
  }
  ::memset(&_impl_.collision_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.state_code_) -
      reinterpret_cast<char*>(&_impl_.collision_count_)) + sizeof(_impl_.state_code_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbBrick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbObject object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 collision_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.collision_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 state_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.state_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbBrick::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbBrick)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbObject object = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // int32 collision_count = 2;
  if (this->_internal_collision_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_collision_count(), target);
  }

  // int32 state_code = 3;
  if (this->_internal_state_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_state_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbBrick)
  return target;
}

::size_t PbBrick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbBrick)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .A0S_proto.PbObject object = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_);
  }

  // int32 collision_count = 2;
  if (this->_internal_collision_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_collision_count());
  }

  // int32 state_code = 3;
  if (this->_internal_state_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_state_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbBrick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbBrick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbBrick::GetClassData() const { return &_class_data_; }


void PbBrick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbBrick*>(&to_msg);
  auto& from = static_cast<const PbBrick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbBrick)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_object()->::A0S_proto::PbObject::MergeFrom(
        from._internal_object());
  }
  if (from._internal_collision_count() != 0) {
    _this->_internal_set_collision_count(from._internal_collision_count());
  }
  if (from._internal_state_code() != 0) {
    _this->_internal_set_state_code(from._internal_state_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbBrick::CopyFrom(const PbBrick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbBrick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbBrick::IsInitialized() const {
  return true;
}

void PbBrick::InternalSwap(PbBrick* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbBrick, _impl_.state_code_)
      + sizeof(PbBrick::_impl_.state_code_)
      - PROTOBUF_FIELD_OFFSET(PbBrick, _impl_.object_)>(
          reinterpret_cast<char*>(&_impl_.object_),
          reinterpret_cast<char*>(&other->_impl_.object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbBrick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[5]);
}
// ===================================================================

class PbTank::_Internal {
 public:
  using HasBits = decltype(std::declval<PbTank>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbTank, _impl_._has_bits_);
  static const ::A0S_proto::PbObject& object(const PbTank* msg);
  static void set_has_object(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::A0S_proto::PbObject&
PbTank::_Internal::object(const PbTank* msg) {
  return *msg->_impl_.object_;
}
PbTank::PbTank(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbTank)
}
PbTank::PbTank(const PbTank& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbTank* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bullets_){from._impl_.bullets_}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.flags_) {}

    , decltype(_impl_.slip_time_) {}

    , decltype(_impl_.new_direction_) {}

    , decltype(_impl_.bullet_max_size_) {}

    , decltype(_impl_.shield_time_) {}

    , decltype(_impl_.frozen_time_) {}

    , decltype(_impl_.default_speed_) {}

    , decltype(_impl_.speed_) {}

    , decltype(_impl_.stop_) {}

    , decltype(_impl_.direction_) {}

    , decltype(_impl_.lives_count_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.object_ = new ::A0S_proto::PbObject(*from._impl_.object_);
  }
  ::memcpy(&_impl_.flags_, &from._impl_.flags_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.lives_count_) -
    reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.lives_count_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbTank)
}

inline void PbTank::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bullets_){arena}
    , decltype(_impl_.object_){nullptr}
    , decltype(_impl_.flags_) { 0 }

    , decltype(_impl_.slip_time_) { 0 }

    , decltype(_impl_.new_direction_) { 0 }

    , decltype(_impl_.bullet_max_size_) { 0u }

    , decltype(_impl_.shield_time_) { 0u }

    , decltype(_impl_.frozen_time_) { 0u }

    , decltype(_impl_.default_speed_) { 0 }

    , decltype(_impl_.speed_) { 0 }

    , decltype(_impl_.stop_) { false }

    , decltype(_impl_.direction_) { 0 }

    , decltype(_impl_.lives_count_) { 0 }

  };
}

PbTank::~PbTank() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbTank)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbTank::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_bullets()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.object_;
}

void PbTank::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbTank::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbTank)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_bullets()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.object_ != nullptr);
    _impl_.object_->Clear();
  }
  ::memset(&_impl_.flags_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.lives_count_) -
      reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.lives_count_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbTank::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbObject object = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbTankStateFlag flags = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_flags(static_cast<::A0S_proto::PbTankStateFlag>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // sint32 slip_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.slip_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbDirection new_direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_new_direction(static_cast<::A0S_proto::PbDirection>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 bullet_max_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.bullet_max_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 shield_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.shield_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 frozen_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.frozen_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // double default_speed = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 65)) {
          _impl_.default_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // double speed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 73)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool stop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _impl_.stop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbDirection direction = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 88)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          _internal_set_direction(static_cast<::A0S_proto::PbDirection>(val));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .A0S_proto.PbBullet bullets = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bullets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 lives_count = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          _impl_.lives_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbTank::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbTank)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbObject object = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::object(this),
        _Internal::object(this).GetCachedSize(), target, stream);
  }

  // .A0S_proto.PbTankStateFlag flags = 2;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_flags(), target);
  }

  // sint32 slip_time = 3;
  if (this->_internal_slip_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        3, this->_internal_slip_time(), target);
  }

  // .A0S_proto.PbDirection new_direction = 4;
  if (this->_internal_new_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_new_direction(), target);
  }

  // uint32 bullet_max_size = 5;
  if (this->_internal_bullet_max_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_bullet_max_size(), target);
  }

  // uint32 shield_time = 6;
  if (this->_internal_shield_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_shield_time(), target);
  }

  // uint32 frozen_time = 7;
  if (this->_internal_frozen_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_frozen_time(), target);
  }

  // double default_speed = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_default_speed = this->_internal_default_speed();
  ::uint64_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        8, this->_internal_default_speed(), target);
  }

  // double speed = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        9, this->_internal_speed(), target);
  }

  // bool stop = 10;
  if (this->_internal_stop() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_stop(), target);
  }

  // .A0S_proto.PbDirection direction = 11;
  if (this->_internal_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        11, this->_internal_direction(), target);
  }

  // repeated .A0S_proto.PbBullet bullets = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_bullets_size()); i < n; i++) {
    const auto& repfield = this->_internal_bullets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 lives_count = 13;
  if (this->_internal_lives_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        13, this->_internal_lives_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbTank)
  return target;
}

::size_t PbTank::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbTank)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .A0S_proto.PbBullet bullets = 12;
  total_size += 1UL * this->_internal_bullets_size();
  for (const auto& msg : this->_internal_bullets()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .A0S_proto.PbObject object = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.object_);
  }

  // .A0S_proto.PbTankStateFlag flags = 2;
  if (this->_internal_flags() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_flags());
  }

  // sint32 slip_time = 3;
  if (this->_internal_slip_time() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_slip_time());
  }

  // .A0S_proto.PbDirection new_direction = 4;
  if (this->_internal_new_direction() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_new_direction());
  }

  // uint32 bullet_max_size = 5;
  if (this->_internal_bullet_max_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_bullet_max_size());
  }

  // uint32 shield_time = 6;
  if (this->_internal_shield_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_shield_time());
  }

  // uint32 frozen_time = 7;
  if (this->_internal_frozen_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_frozen_time());
  }

  // double default_speed = 8;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_default_speed = this->_internal_default_speed();
  ::uint64_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    total_size += 9;
  }

  // double speed = 9;
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 9;
  }

  // bool stop = 10;
  if (this->_internal_stop() != 0) {
    total_size += 2;
  }

  // .A0S_proto.PbDirection direction = 11;
  if (this->_internal_direction() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  // int32 lives_count = 13;
  if (this->_internal_lives_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_lives_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbTank::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbTank::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbTank::GetClassData() const { return &_class_data_; }


void PbTank::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbTank*>(&to_msg);
  auto& from = static_cast<const PbTank&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbTank)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_bullets()->MergeFrom(from._internal_bullets());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_object()->::A0S_proto::PbObject::MergeFrom(
        from._internal_object());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_slip_time() != 0) {
    _this->_internal_set_slip_time(from._internal_slip_time());
  }
  if (from._internal_new_direction() != 0) {
    _this->_internal_set_new_direction(from._internal_new_direction());
  }
  if (from._internal_bullet_max_size() != 0) {
    _this->_internal_set_bullet_max_size(from._internal_bullet_max_size());
  }
  if (from._internal_shield_time() != 0) {
    _this->_internal_set_shield_time(from._internal_shield_time());
  }
  if (from._internal_frozen_time() != 0) {
    _this->_internal_set_frozen_time(from._internal_frozen_time());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_default_speed = from._internal_default_speed();
  ::uint64_t raw_default_speed;
  memcpy(&raw_default_speed, &tmp_default_speed, sizeof(tmp_default_speed));
  if (raw_default_speed != 0) {
    _this->_internal_set_default_speed(from._internal_default_speed());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double), "Code assumes ::uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  ::uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_stop() != 0) {
    _this->_internal_set_stop(from._internal_stop());
  }
  if (from._internal_direction() != 0) {
    _this->_internal_set_direction(from._internal_direction());
  }
  if (from._internal_lives_count() != 0) {
    _this->_internal_set_lives_count(from._internal_lives_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbTank::CopyFrom(const PbTank& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbTank)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbTank::IsInitialized() const {
  return true;
}

void PbTank::InternalSwap(PbTank* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_bullets()->InternalSwap(other->_internal_mutable_bullets());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbTank, _impl_.lives_count_)
      + sizeof(PbTank::_impl_.lives_count_)
      - PROTOBUF_FIELD_OFFSET(PbTank, _impl_.object_)>(
          reinterpret_cast<char*>(&_impl_.object_),
          reinterpret_cast<char*>(&other->_impl_.object_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbTank::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[6]);
}
// ===================================================================

class PbPlayer::_Internal {
 public:
  using HasBits = decltype(std::declval<PbPlayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbPlayer, _impl_._has_bits_);
  static const ::A0S_proto::PbTank& tank(const PbPlayer* msg);
  static void set_has_tank(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::A0S_proto::PbTank&
PbPlayer::_Internal::tank(const PbPlayer* msg) {
  return *msg->_impl_.tank_;
}
PbPlayer::PbPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbPlayer)
}
PbPlayer::PbPlayer(const PbPlayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbPlayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tank_){nullptr}
    , decltype(_impl_.star_count_) {}

    , decltype(_impl_.fire_time_) {}

    , decltype(_impl_.movement_) {}

    , decltype(_impl_.menu_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.tank_ = new ::A0S_proto::PbTank(*from._impl_.tank_);
  }
  ::memcpy(&_impl_.star_count_, &from._impl_.star_count_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.menu_) -
    reinterpret_cast<char*>(&_impl_.star_count_)) + sizeof(_impl_.menu_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbPlayer)
}

inline void PbPlayer::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tank_){nullptr}
    , decltype(_impl_.star_count_) { 0 }

    , decltype(_impl_.fire_time_) { 0u }

    , decltype(_impl_.movement_) { false }

    , decltype(_impl_.menu_) { false }

  };
}

PbPlayer::~PbPlayer() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbPlayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbPlayer::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tank_;
}

void PbPlayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbPlayer::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbPlayer)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.tank_ != nullptr);
    _impl_.tank_->Clear();
  }
  ::memset(&_impl_.star_count_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.menu_) -
      reinterpret_cast<char*>(&_impl_.star_count_)) + sizeof(_impl_.menu_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbPlayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbTank tank = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tank(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // int32 star_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.star_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 fire_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.fire_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool movement = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.movement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // bool menu = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.menu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbPlayer::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbPlayer)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbTank tank = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tank(this),
        _Internal::tank(this).GetCachedSize(), target, stream);
  }

  // int32 star_count = 2;
  if (this->_internal_star_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        2, this->_internal_star_count(), target);
  }

  // uint32 fire_time = 3;
  if (this->_internal_fire_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_fire_time(), target);
  }

  // bool movement = 4;
  if (this->_internal_movement() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_movement(), target);
  }

  // bool menu = 5;
  if (this->_internal_menu() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_menu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbPlayer)
  return target;
}

::size_t PbPlayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbPlayer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .A0S_proto.PbTank tank = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tank_);
  }

  // int32 star_count = 2;
  if (this->_internal_star_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_star_count());
  }

  // uint32 fire_time = 3;
  if (this->_internal_fire_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_fire_time());
  }

  // bool movement = 4;
  if (this->_internal_movement() != 0) {
    total_size += 2;
  }

  // bool menu = 5;
  if (this->_internal_menu() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbPlayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbPlayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbPlayer::GetClassData() const { return &_class_data_; }


void PbPlayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbPlayer*>(&to_msg);
  auto& from = static_cast<const PbPlayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbPlayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_tank()->::A0S_proto::PbTank::MergeFrom(
        from._internal_tank());
  }
  if (from._internal_star_count() != 0) {
    _this->_internal_set_star_count(from._internal_star_count());
  }
  if (from._internal_fire_time() != 0) {
    _this->_internal_set_fire_time(from._internal_fire_time());
  }
  if (from._internal_movement() != 0) {
    _this->_internal_set_movement(from._internal_movement());
  }
  if (from._internal_menu() != 0) {
    _this->_internal_set_menu(from._internal_menu());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbPlayer::CopyFrom(const PbPlayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbPlayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbPlayer::IsInitialized() const {
  return true;
}

void PbPlayer::InternalSwap(PbPlayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbPlayer, _impl_.menu_)
      + sizeof(PbPlayer::_impl_.menu_)
      - PROTOBUF_FIELD_OFFSET(PbPlayer, _impl_.tank_)>(
          reinterpret_cast<char*>(&_impl_.tank_),
          reinterpret_cast<char*>(&other->_impl_.tank_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbPlayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[7]);
}
// ===================================================================

class PbEnemy::_Internal {
 public:
  using HasBits = decltype(std::declval<PbEnemy>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PbEnemy, _impl_._has_bits_);
  static const ::A0S_proto::PbTank& tank(const PbEnemy* msg);
  static void set_has_tank(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::A0S_proto::PbSdlPoint& target_position(const PbEnemy* msg);
  static void set_has_target_position(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::A0S_proto::PbTank&
PbEnemy::_Internal::tank(const PbEnemy* msg) {
  return *msg->_impl_.tank_;
}
const ::A0S_proto::PbSdlPoint&
PbEnemy::_Internal::target_position(const PbEnemy* msg) {
  return *msg->_impl_.target_position_;
}
PbEnemy::PbEnemy(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:A0S_proto.PbEnemy)
}
PbEnemy::PbEnemy(const PbEnemy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PbEnemy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tank_){nullptr}
    , decltype(_impl_.target_position_){nullptr}
    , decltype(_impl_.direction_time_) {}

    , decltype(_impl_.keep_direction_time_) {}

    , decltype(_impl_.speed_time_) {}

    , decltype(_impl_.try_to_go_time_) {}

    , decltype(_impl_.fire_time_) {}

    , decltype(_impl_.reload_time_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.tank_ = new ::A0S_proto::PbTank(*from._impl_.tank_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.target_position_ = new ::A0S_proto::PbSdlPoint(*from._impl_.target_position_);
  }
  ::memcpy(&_impl_.direction_time_, &from._impl_.direction_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.reload_time_) -
    reinterpret_cast<char*>(&_impl_.direction_time_)) + sizeof(_impl_.reload_time_));
  // @@protoc_insertion_point(copy_constructor:A0S_proto.PbEnemy)
}

inline void PbEnemy::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tank_){nullptr}
    , decltype(_impl_.target_position_){nullptr}
    , decltype(_impl_.direction_time_) { 0u }

    , decltype(_impl_.keep_direction_time_) { 0u }

    , decltype(_impl_.speed_time_) { 0u }

    , decltype(_impl_.try_to_go_time_) { 0u }

    , decltype(_impl_.fire_time_) { 0u }

    , decltype(_impl_.reload_time_) { 0u }

  };
}

PbEnemy::~PbEnemy() {
  // @@protoc_insertion_point(destructor:A0S_proto.PbEnemy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PbEnemy::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tank_;
  if (this != internal_default_instance()) delete _impl_.target_position_;
}

void PbEnemy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PbEnemy::Clear() {
// @@protoc_insertion_point(message_clear_start:A0S_proto.PbEnemy)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.tank_ != nullptr);
      _impl_.tank_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.target_position_ != nullptr);
      _impl_.target_position_->Clear();
    }
  }
  ::memset(&_impl_.direction_time_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.reload_time_) -
      reinterpret_cast<char*>(&_impl_.direction_time_)) + sizeof(_impl_.reload_time_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PbEnemy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .A0S_proto.PbTank tank = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tank(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 direction_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _impl_.direction_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 keep_direction_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _impl_.keep_direction_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 speed_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _impl_.speed_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 try_to_go_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _impl_.try_to_go_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 fire_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _impl_.fire_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // uint32 reload_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          _impl_.reload_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .A0S_proto.PbSdlPoint target_position = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_target_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PbEnemy::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:A0S_proto.PbEnemy)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .A0S_proto.PbTank tank = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tank(this),
        _Internal::tank(this).GetCachedSize(), target, stream);
  }

  // uint32 direction_time = 2;
  if (this->_internal_direction_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_direction_time(), target);
  }

  // uint32 keep_direction_time = 3;
  if (this->_internal_keep_direction_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_keep_direction_time(), target);
  }

  // uint32 speed_time = 4;
  if (this->_internal_speed_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_speed_time(), target);
  }

  // uint32 try_to_go_time = 5;
  if (this->_internal_try_to_go_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_try_to_go_time(), target);
  }

  // uint32 fire_time = 6;
  if (this->_internal_fire_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_fire_time(), target);
  }

  // uint32 reload_time = 7;
  if (this->_internal_reload_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_reload_time(), target);
  }

  // .A0S_proto.PbSdlPoint target_position = 8;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::target_position(this),
        _Internal::target_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:A0S_proto.PbEnemy)
  return target;
}

::size_t PbEnemy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:A0S_proto.PbEnemy)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .A0S_proto.PbTank tank = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tank_);
    }

    // .A0S_proto.PbSdlPoint target_position = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.target_position_);
    }

  }
  // uint32 direction_time = 2;
  if (this->_internal_direction_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_direction_time());
  }

  // uint32 keep_direction_time = 3;
  if (this->_internal_keep_direction_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_keep_direction_time());
  }

  // uint32 speed_time = 4;
  if (this->_internal_speed_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_speed_time());
  }

  // uint32 try_to_go_time = 5;
  if (this->_internal_try_to_go_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_try_to_go_time());
  }

  // uint32 fire_time = 6;
  if (this->_internal_fire_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_fire_time());
  }

  // uint32 reload_time = 7;
  if (this->_internal_reload_time() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_reload_time());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PbEnemy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PbEnemy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PbEnemy::GetClassData() const { return &_class_data_; }


void PbEnemy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PbEnemy*>(&to_msg);
  auto& from = static_cast<const PbEnemy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:A0S_proto.PbEnemy)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tank()->::A0S_proto::PbTank::MergeFrom(
          from._internal_tank());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_target_position()->::A0S_proto::PbSdlPoint::MergeFrom(
          from._internal_target_position());
    }
  }
  if (from._internal_direction_time() != 0) {
    _this->_internal_set_direction_time(from._internal_direction_time());
  }
  if (from._internal_keep_direction_time() != 0) {
    _this->_internal_set_keep_direction_time(from._internal_keep_direction_time());
  }
  if (from._internal_speed_time() != 0) {
    _this->_internal_set_speed_time(from._internal_speed_time());
  }
  if (from._internal_try_to_go_time() != 0) {
    _this->_internal_set_try_to_go_time(from._internal_try_to_go_time());
  }
  if (from._internal_fire_time() != 0) {
    _this->_internal_set_fire_time(from._internal_fire_time());
  }
  if (from._internal_reload_time() != 0) {
    _this->_internal_set_reload_time(from._internal_reload_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PbEnemy::CopyFrom(const PbEnemy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:A0S_proto.PbEnemy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PbEnemy::IsInitialized() const {
  return true;
}

void PbEnemy::InternalSwap(PbEnemy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PbEnemy, _impl_.reload_time_)
      + sizeof(PbEnemy::_impl_.reload_time_)
      - PROTOBUF_FIELD_OFFSET(PbEnemy, _impl_.tank_)>(
          reinterpret_cast<char*>(&_impl_.tank_),
          reinterpret_cast<char*>(&other->_impl_.tank_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PbEnemy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_acme_2eproto_getter, &descriptor_table_acme_2eproto_once,
      file_level_metadata_acme_2eproto[8]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace A0S_proto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::A0S_proto::PbSdlRect*
Arena::CreateMaybeMessage< ::A0S_proto::PbSdlRect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbSdlRect >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbSdlPoint*
Arena::CreateMaybeMessage< ::A0S_proto::PbSdlPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbSdlPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbObject*
Arena::CreateMaybeMessage< ::A0S_proto::PbObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbObject >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbBullet*
Arena::CreateMaybeMessage< ::A0S_proto::PbBullet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbBullet >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbBonus*
Arena::CreateMaybeMessage< ::A0S_proto::PbBonus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbBonus >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbBrick*
Arena::CreateMaybeMessage< ::A0S_proto::PbBrick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbBrick >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbTank*
Arena::CreateMaybeMessage< ::A0S_proto::PbTank >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbTank >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbPlayer*
Arena::CreateMaybeMessage< ::A0S_proto::PbPlayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbPlayer >(arena);
}
template<> PROTOBUF_NOINLINE ::A0S_proto::PbEnemy*
Arena::CreateMaybeMessage< ::A0S_proto::PbEnemy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::A0S_proto::PbEnemy >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
