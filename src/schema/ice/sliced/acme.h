//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `acme.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __acme_h__
#define __acme_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Acme
{

class BaseObject;
class Bonus;
class Brick;
class Bullet;
class Eagle;
class Bullet2;
class BulletMix2;
class Tank;
class Enemy;
class Player;

}

namespace Acme
{

/**
 * A rectangle, with the origin at the upper left (integer).
 *
 * \sa SDL_RectEmpty
 * \sa SDL_RectEquals
 * \sa SDL_HasIntersection
 * \sa SDL_IntersectRect
 * \sa SDL_IntersectRectAndLine
 * \sa SDL_UnionRect
 * \sa SDL_EnclosePoints
 */
struct SDL_Rect
{
    int x;
    int y;
    int w;
    int h;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(x, y, w, h);
    }
};

/**
 * The structure that defines a point (integer)
 *
 * \sa SDL_EnclosePoints
 * \sa SDL_PointInRect
 */
struct SDL_Point
{
    int x;
    int y;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&> ice_tuple() const
    {
        return std::tie(x, y);
    }
};

enum class Direction : unsigned char
{
    D_UP = 0,
    D_RIGHT = 1,
    D_DOWN = 2,
    D_LEFT = 3
};

enum class TankStateFlag
{
    TSF_DEFAULT = 1,
    TSF_SHIELD = 2,
    TSF_FROZEN = 4,
    TSF_DESTROYED = 8,
    TSF_BOAT = 16,
    TSF_BONUS = 32,
    TSF_ON_ICE = 64,
    TSF_CREATE = 128,
    TSF_LIFE = 256,
    TSF_MENU = 512
};

enum class SpriteType : unsigned char
{
    ST_TANK_A,
    ST_TANK_B,
    ST_TANK_C,
    ST_TANK_D,
    ST_PLAYER_1,
    ST_PLAYER_2,
    ST_BRICK_WALL,
    ST_STONE_WALL,
    ST_WATER,
    ST_BUSH,
    ST_ICE,
    ST_BONUS_GRENADE,
    ST_BONUS_HELMET,
    ST_BONUS_CLOCK,
    ST_BONUS_SHOVEL,
    ST_BONUS_TANK,
    ST_BONUS_STAR,
    ST_BONUS_GUN,
    ST_BONUS_BOAT,
    ST_SHIELD,
    ST_CREATE,
    ST_DESTROY_TANK,
    ST_DESTROY_BULLET,
    ST_BOAT_P1,
    ST_BOAT_P2,
    ST_EAGLE,
    ST_DESTROY_EAGLE,
    ST_FLAG,
    ST_BULLET,
    ST_LEFT_ENEMY,
    ST_STAGE_STATUS,
    ST_TANKS_LOGO,
    ST_NONE
};

using BulletSequence2 = ::std::vector<::std::shared_ptr<BulletMix2>>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Acme
{

/**
 * @brief Base class for game objects
 */
class BaseObject
{
public:

    virtual ~BaseObject();

    BaseObject() = default;

    BaseObject(const BaseObject&) = default;
    BaseObject(BaseObject&&) = default;
    BaseObject& operator=(const BaseObject&) = default;
    BaseObject& operator=(BaseObject&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     */
    BaseObject(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y) :
        m_frame_display_time(m_frame_display_time),
        m_current_frame(m_current_frame),
        to_erase(to_erase),
        collision_rect(collision_rect),
        dest_rect(dest_rect),
        src_rect(src_rect),
        type(type),
        pos_x(pos_x),
        pos_y(pos_y)
    {
    }

protected:

    /**
     * Display time of the current animation frame.
     */
    int m_frame_display_time;
    /**
     * Number of the current animation frame.
     */
    int m_current_frame;

public:

    /**
     * The variable says whether the object should be deleted. If change is equal to @a true, no updating and drawing of the object is skipped.
     */
    bool to_erase;
    /**
     * Collision rectangle; may be smaller than the dimensions of dest_rect.
     */
    ::Acme::SDL_Rect collision_rect;
    /**
     * The target position of the object on the screen.
     */
    ::Acme::SDL_Rect dest_rect;
    /**
     * Position on the texture of the currently displayed frame.
     */
    ::Acme::SDL_Rect src_rect;
    /**
     * BaseObject type.
     */
    ::Acme::SpriteType type;
    /**
     * Accurate horizontal position of the object.
     */
    double pos_x;
    /**
     * Accurate vertical position of the object.
     */
    double pos_y;
};

/**
 * @brief Class dealing with displaying the bonus.
 */
class Bonus : public ::Acme::BaseObject
{
public:

    virtual ~Bonus();

    Bonus() = default;

    Bonus(const Bonus&) = default;
    Bonus(Bonus&&) = default;
    Bonus& operator=(const Bonus&) = default;
    Bonus& operator=(Bonus&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_bonus_show_time Time since bonus creation.
     * @param m_show Variable storing information about whether the bonus is currently displayed; used for flashing.
     */
    Bonus(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, int m_bonus_show_time, bool m_show) :
        BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_bonus_show_time(m_bonus_show_time),
        m_show(m_show)
    {
    }

protected:

    /**
     * Time since bonus creation.
     */
    int m_bonus_show_time;
    /**
     * Variable storing information about whether the bonus is currently displayed; used for flashing.
     */
    bool m_show;
};

/**
 * @brief Class responsible for a single piece of wall.
 * @see BaseObject
 */
class Brick : public ::Acme::BaseObject
{
public:

    virtual ~Brick();

    Brick() = default;

    Brick(const Brick&) = default;
    Brick(Brick&&) = default;
    Brick& operator=(const Brick&) = default;
    Brick& operator=(Brick&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_collision_count Number of times the bullets hit the wall.
     * @param m_state_code One of the ten states in which a wall can be.
     */
    Brick(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, int m_collision_count, int m_state_code) :
        BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_collision_count(m_collision_count),
        m_state_code(m_state_code)
    {
    }

protected:

    /**
     * Number of times the bullets hit the wall.
     */
    int m_collision_count;
    /**
     * One of the ten states in which a wall can be.
     */
    int m_state_code;
};

/**
 * @brief Class dealing with projectiles fired by tanks.
 */
class Bullet : public ::Acme::BaseObject
{
public:

    virtual ~Bullet();

    Bullet() = default;

    Bullet(const Bullet&) = default;
    Bullet(Bullet&&) = default;
    Bullet& operator=(const Bullet&) = default;
    Bullet& operator=(Bullet&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param speed Projectile speed.
     * @param collide The variable stores information whether the bullet collided with something.
     * @param increased_damage The variable stores information whether the bullet has increased damage.
     * @param direction The direction of the bullet's movement.
     */
    Bullet(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, double speed, bool collide, bool increased_damage, ::Acme::Direction direction) :
        BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        speed(speed),
        collide(collide),
        increased_damage(increased_damage),
        direction(direction)
    {
    }

    /**
     * Projectile speed.
     */
    double speed;
    /**
     * The variable stores information whether the bullet collided with something.
     */
    bool collide;
    /**
     * The variable stores information whether the bullet has increased damage.
     * Increased damage allows you to destroy stone walls and bushes.
     */
    bool increased_damage;
    /**
     * The direction of the bullet's movement.
     */
    ::Acme::Direction direction;
};

/**
 * @brief An eagle class that players must defend and opponents must destroy.
 */
class Eagle : public ::Acme::BaseObject
{
public:

    virtual ~Eagle();

    Eagle() = default;

    Eagle(const Eagle&) = default;
    Eagle(Eagle&&) = default;
    Eagle& operator=(const Eagle&) = default;
    Eagle& operator=(Eagle&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     */
    Eagle(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y) :
        BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y)
    {
    }
};

class Bullet2
{
public:

    virtual ~Bullet2();

    Bullet2() = default;

    Bullet2(const Bullet2&) = default;
    Bullet2(Bullet2&&) = default;
    Bullet2& operator=(const Bullet2&) = default;
    Bullet2& operator=(Bullet2&&) = default;
};

class BulletMix2
{
public:

    virtual ~BulletMix2();

    virtual ::std::shared_ptr<::Acme::Bullet2> get() = 0;

    virtual void set(const ::std::shared_ptr<Bullet2>& bullet) = 0;
};

/**
 * @brief
 * A class dealing with basic tank mechanics: driving, shooting.
 */
class Tank : public ::Acme::BaseObject
{
public:

    virtual ~Tank();

    Tank() :
        m_flags(::Acme::TankStateFlag::TSF_DEFAULT)
    {
    }

    Tank(const Tank&) = default;
    Tank(Tank&&) = default;
    Tank& operator=(const Tank&) = default;
    Tank& operator=(Tank&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     */
    Tank(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, ::Acme::TankStateFlag m_flags, int m_slip_time, ::Acme::Direction new_direction, int m_bullet_max_size, int m_shield_time, int m_frozen_time, double default_speed, double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, int lives_count) :
        BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_flags(m_flags),
        m_slip_time(m_slip_time),
        new_direction(new_direction),
        m_bullet_max_size(m_bullet_max_size),
        m_shield_time(m_shield_time),
        m_frozen_time(m_frozen_time),
        default_speed(default_speed),
        speed(speed),
        stop(stop),
        direction(direction),
        bullets(bullets),
        lives_count(lives_count)
    {
    }

protected:

    /**
     * Flags that the tank currently has.
     */
    ::Acme::TankStateFlag m_flags = ::Acme::TankStateFlag::TSF_DEFAULT;
    /**
     * Time since slippage occurred.
     */
    int m_slip_time;
    /**
     * Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     */
    ::Acme::Direction new_direction;
    /**
     * The maximum number of bullets that the tank can fire.
     */
    int m_bullet_max_size;
    /**
     * Time since gaining cover.
     */
    int m_shield_time;
    /**
     * Time since the tank was frozen.
     */
    int m_frozen_time;

public:

    /**
     * Default speed of a given tank. It may be different for different types of tanks or may be changed after the player takes the bonus.
     */
    double default_speed;
    /**
     * Current tank speed.
     */
    double speed;
    /**
     * The variable stores information whether the tank is currently stopped.
     */
    bool stop;
    /**
     * Variable stores the current driving direction of the tank.
     */
    ::Acme::Direction direction;
    /**
     * Container with fired tank missiles.
     */
    ::Acme::BulletSequence2 bullets;
    /**
     * The number of player lives or the armor level number of the enemy tank.
     */
    int lives_count;
};

/**
 * @brief Class dealing with enemy tank movements.
 */
class Enemy : public ::Acme::Tank
{
public:

    virtual ~Enemy();

    Enemy() = default;

    Enemy(const Enemy&) = default;
    Enemy(Enemy&&) = default;
    Enemy& operator=(const Enemy&) = default;
    Enemy& operator=(Enemy&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     * @param m_direction_time Time since last change of direction.
     * @param m_keep_direction_time Driving time in a given direction.
     * @param m_speed_time Time since last attempt to resume driving
     * @param m_try_to_go_time Time after which the next resumption of driving will occur; non-zero speed setting.
     * @param m_fire_time Time since the last missile launch attempt.
     * @param m_reload_time The time after which another shot will be attempted.
     * @param target_position The position to which the enemy tank is heading.
     */
    Enemy(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, ::Acme::TankStateFlag m_flags, int m_slip_time, ::Acme::Direction new_direction, int m_bullet_max_size, int m_shield_time, int m_frozen_time, double default_speed, double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, int lives_count, int m_direction_time, int m_keep_direction_time, int m_speed_time, int m_try_to_go_time, int m_fire_time, int m_reload_time, const ::Acme::SDL_Point& target_position) :
        Tank(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y, m_flags, m_slip_time, new_direction, m_bullet_max_size, m_shield_time, m_frozen_time, default_speed, speed, stop, direction, bullets, lives_count),
        m_direction_time(m_direction_time),
        m_keep_direction_time(m_keep_direction_time),
        m_speed_time(m_speed_time),
        m_try_to_go_time(m_try_to_go_time),
        m_fire_time(m_fire_time),
        m_reload_time(m_reload_time),
        target_position(target_position)
    {
    }

protected:

    /**
     * Time since last change of direction.
     */
    int m_direction_time;
    /**
     * Driving time in a given direction. The time after which the direction will change.
     */
    int m_keep_direction_time;
    /**
     * Time since last attempt to resume driving
     */
    int m_speed_time;
    /**
     * Time after which the next resumption of driving will occur; non-zero speed setting.
     */
    int m_try_to_go_time;
    /**
     * Time since the last missile launch attempt.
     */
    int m_fire_time;
    /**
     * The time after which another shot will be attempted.
     */
    int m_reload_time;

public:

    /**
     * The position to which the enemy tank is heading.
     */
    ::Acme::SDL_Point target_position;
};

/**
 * @brief Class corresponding to player tanks.
 */
class Player : public ::Acme::Tank
{
public:

    virtual ~Player();

    Player() :
        star_count(0),
        m_fire_time(0),
        m_movement(false),
        m_menu(false)
    {
    }

    Player(const Player&) = default;
    Player(Player&&) = default;
    Player& operator=(const Player&) = default;
    Player& operator=(Player&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     * @param star_count Current number of stars; may be in the range [0, 3].
     * @param m_fire_time The time that has passed since the last missile shot.
     * @param m_movement Machine is in movement.
     * @param m_menu It is menu tank.
     * @param score The player's current points.
     */
    Player(int m_frame_display_time, int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, double pos_x, double pos_y, ::Acme::TankStateFlag m_flags, int m_slip_time, ::Acme::Direction new_direction, int m_bullet_max_size, int m_shield_time, int m_frozen_time, double default_speed, double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, int lives_count, int star_count, int m_fire_time, bool m_movement, bool m_menu, int score) :
        Tank(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y, m_flags, m_slip_time, new_direction, m_bullet_max_size, m_shield_time, m_frozen_time, default_speed, speed, stop, direction, bullets, lives_count),
        star_count(star_count),
        m_fire_time(m_fire_time),
        m_movement(m_movement),
        m_menu(m_menu),
        score(score)
    {
    }

protected:

    /**
     * Current number of stars; may be in the range [0, 3].
     */
    int star_count = 0;
    /**
     * The time that has passed since the last missile shot.
     */
    int m_fire_time = 0;
    /**
     * Machine is in movement.
     */
    bool m_movement = false;
    /**
     * It is menu tank.
     */
    bool m_menu = false;

public:

    /**
     * The player's current points.
     */
    int score;
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Acme::SDL_Rect>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Acme::SDL_Rect, S>
{
    static void read(S* istr, ::Acme::SDL_Rect& v)
    {
        istr->readAll(v.x, v.y, v.w, v.h);
    }
};

template<>
struct StreamableTraits<::Acme::SDL_Point>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::Acme::SDL_Point, S>
{
    static void read(S* istr, ::Acme::SDL_Point& v)
    {
        istr->readAll(v.x, v.y);
    }
};

template<>
struct StreamableTraits< ::Acme::Direction>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Acme::TankStateFlag>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 512;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Acme::SpriteType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 32;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

/// \cond INTERNAL
namespace Acme
{

using BaseObjectPtr = ::std::shared_ptr<BaseObject>;

using BonusPtr = ::std::shared_ptr<Bonus>;

using BrickPtr = ::std::shared_ptr<Brick>;

using BulletPtr = ::std::shared_ptr<Bullet>;

using EaglePtr = ::std::shared_ptr<Eagle>;

using Bullet2Ptr = ::std::shared_ptr<Bullet2>;

using BulletMix2Ptr = ::std::shared_ptr<BulletMix2>;

using TankPtr = ::std::shared_ptr<Tank>;

using EnemyPtr = ::std::shared_ptr<Enemy>;

using PlayerPtr = ::std::shared_ptr<Player>;

}
/// \endcond

#else // C++98 mapping

namespace Acme
{

class BaseObject;
/// \cond INTERNAL
::Ice::LocalObject* upCast(BaseObject*);
/// \endcond
typedef ::IceInternal::Handle< BaseObject> BaseObjectPtr;

class Bonus;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Bonus*);
/// \endcond
typedef ::IceInternal::Handle< Bonus> BonusPtr;

class Brick;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Brick*);
/// \endcond
typedef ::IceInternal::Handle< Brick> BrickPtr;

class Bullet;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Bullet*);
/// \endcond
typedef ::IceInternal::Handle< Bullet> BulletPtr;

class Eagle;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Eagle*);
/// \endcond
typedef ::IceInternal::Handle< Eagle> EaglePtr;

class Bullet2;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Bullet2*);
/// \endcond
typedef ::IceInternal::Handle< Bullet2> Bullet2Ptr;

class BulletMix2;
/// \cond INTERNAL
::Ice::LocalObject* upCast(BulletMix2*);
/// \endcond
typedef ::IceInternal::Handle< BulletMix2> BulletMix2Ptr;

class Tank;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Tank*);
/// \endcond
typedef ::IceInternal::Handle< Tank> TankPtr;

class Enemy;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Enemy*);
/// \endcond
typedef ::IceInternal::Handle< Enemy> EnemyPtr;

class Player;
/// \cond INTERNAL
::Ice::LocalObject* upCast(Player*);
/// \endcond
typedef ::IceInternal::Handle< Player> PlayerPtr;

}

namespace Acme
{

/**
 * A rectangle, with the origin at the upper left (integer).
 *
 * \sa SDL_RectEmpty
 * \sa SDL_RectEquals
 * \sa SDL_HasIntersection
 * \sa SDL_IntersectRect
 * \sa SDL_IntersectRectAndLine
 * \sa SDL_UnionRect
 * \sa SDL_EnclosePoints
 */
struct SDL_Rect
{
    ::Ice::Int x;
    ::Ice::Int y;
    ::Ice::Int w;
    ::Ice::Int h;

    bool operator==(const SDL_Rect& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        if(w != rhs_.w)
        {
            return false;
        }
        if(h != rhs_.h)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SDL_Rect& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        if(w < rhs_.w)
        {
            return true;
        }
        else if(rhs_.w < w)
        {
            return false;
        }
        if(h < rhs_.h)
        {
            return true;
        }
        else if(rhs_.h < h)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SDL_Rect& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SDL_Rect& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SDL_Rect& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SDL_Rect& rhs_) const
    {
        return !operator<(rhs_);
    }
};

/**
 * The structure that defines a point (integer)
 *
 * \sa SDL_EnclosePoints
 * \sa SDL_PointInRect
 */
struct SDL_Point
{
    ::Ice::Int x;
    ::Ice::Int y;

    bool operator==(const SDL_Point& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        return true;
    }

    bool operator<(const SDL_Point& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const SDL_Point& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const SDL_Point& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const SDL_Point& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const SDL_Point& rhs_) const
    {
        return !operator<(rhs_);
    }
};

enum Direction
{
    D_UP = 0,
    D_RIGHT = 1,
    D_DOWN = 2,
    D_LEFT = 3
};

enum TankStateFlag
{
    TSF_DEFAULT = 1,
    TSF_SHIELD = 2,
    TSF_FROZEN = 4,
    TSF_DESTROYED = 8,
    TSF_BOAT = 16,
    TSF_BONUS = 32,
    TSF_ON_ICE = 64,
    TSF_CREATE = 128,
    TSF_LIFE = 256,
    TSF_MENU = 512
};

enum SpriteType
{
    ST_TANK_A,
    ST_TANK_B,
    ST_TANK_C,
    ST_TANK_D,
    ST_PLAYER_1,
    ST_PLAYER_2,
    ST_BRICK_WALL,
    ST_STONE_WALL,
    ST_WATER,
    ST_BUSH,
    ST_ICE,
    ST_BONUS_GRENADE,
    ST_BONUS_HELMET,
    ST_BONUS_CLOCK,
    ST_BONUS_SHOVEL,
    ST_BONUS_TANK,
    ST_BONUS_STAR,
    ST_BONUS_GUN,
    ST_BONUS_BOAT,
    ST_SHIELD,
    ST_CREATE,
    ST_DESTROY_TANK,
    ST_DESTROY_BULLET,
    ST_BOAT_P1,
    ST_BOAT_P2,
    ST_EAGLE,
    ST_DESTROY_EAGLE,
    ST_FLAG,
    ST_BULLET,
    ST_LEFT_ENEMY,
    ST_STAGE_STATUS,
    ST_TANKS_LOGO,
    ST_NONE
};

typedef ::std::vector<BulletMix2Ptr> BulletSequence2;

}

namespace Acme
{

/**
 * @brief Base class for game objects
 */
class BaseObject : public virtual ::Ice::LocalObject
{
public:

    typedef BaseObjectPtr PointerType;

    virtual ~BaseObject();

    BaseObject()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     */
    BaseObject(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y) :
        m_frame_display_time(m_frame_display_time),
        m_current_frame(m_current_frame),
        to_erase(to_erase),
        collision_rect(collision_rect),
        dest_rect(dest_rect),
        src_rect(src_rect),
        type(type),
        pos_x(pos_x),
        pos_y(pos_y)
    {
    }

#ifdef ICE_CPP11_COMPILER
    BaseObject(const BaseObject&) = default;
    BaseObject& operator=(const BaseObject&) = default;
#endif

protected:

    /**
     * Display time of the current animation frame.
     */
    ::Ice::Int m_frame_display_time;
    /**
     * Number of the current animation frame.
     */
    ::Ice::Int m_current_frame;

public:

    /**
     * The variable says whether the object should be deleted. If change is equal to @a true, no updating and drawing of the object is skipped.
     */
    bool to_erase;
    /**
     * Collision rectangle; may be smaller than the dimensions of dest_rect.
     */
    ::Acme::SDL_Rect collision_rect;
    /**
     * The target position of the object on the screen.
     */
    ::Acme::SDL_Rect dest_rect;
    /**
     * Position on the texture of the currently displayed frame.
     */
    ::Acme::SDL_Rect src_rect;
    /**
     * BaseObject type.
     */
    ::Acme::SpriteType type;
    /**
     * Accurate horizontal position of the object.
     */
    ::Ice::Double pos_x;
    /**
     * Accurate vertical position of the object.
     */
    ::Ice::Double pos_y;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const BaseObject& lhs, const BaseObject& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const BaseObject& lhs, const BaseObject& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief Class dealing with displaying the bonus.
 */
class Bonus : virtual public BaseObject
{
public:

    typedef BonusPtr PointerType;

    virtual ~Bonus();

    Bonus()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_bonus_show_time Time since bonus creation.
     * @param m_show Variable storing information about whether the bonus is currently displayed; used for flashing.
     */
    Bonus(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Ice::Int m_bonus_show_time, bool m_show) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_bonus_show_time(m_bonus_show_time),
        m_show(m_show)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Bonus(const Bonus&) = default;
    Bonus& operator=(const Bonus&) = default;
#endif

protected:

    /**
     * Time since bonus creation.
     */
    ::Ice::Int m_bonus_show_time;
    /**
     * Variable storing information about whether the bonus is currently displayed; used for flashing.
     */
    bool m_show;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const Bonus& lhs, const Bonus& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Bonus& lhs, const Bonus& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief Class responsible for a single piece of wall.
 * @see BaseObject
 */
class Brick : virtual public BaseObject
{
public:

    typedef BrickPtr PointerType;

    virtual ~Brick();

    Brick()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_collision_count Number of times the bullets hit the wall.
     * @param m_state_code One of the ten states in which a wall can be.
     */
    Brick(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Ice::Int m_collision_count, ::Ice::Int m_state_code) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_collision_count(m_collision_count),
        m_state_code(m_state_code)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Brick(const Brick&) = default;
    Brick& operator=(const Brick&) = default;
#endif

protected:

    /**
     * Number of times the bullets hit the wall.
     */
    ::Ice::Int m_collision_count;
    /**
     * One of the ten states in which a wall can be.
     */
    ::Ice::Int m_state_code;

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const Brick& lhs, const Brick& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Brick& lhs, const Brick& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief Class dealing with projectiles fired by tanks.
 */
class Bullet : virtual public BaseObject
{
public:

    typedef BulletPtr PointerType;

    virtual ~Bullet();

    Bullet()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param speed Projectile speed.
     * @param collide The variable stores information whether the bullet collided with something.
     * @param increased_damage The variable stores information whether the bullet has increased damage.
     * @param direction The direction of the bullet's movement.
     */
    Bullet(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Ice::Double speed, bool collide, bool increased_damage, ::Acme::Direction direction) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        speed(speed),
        collide(collide),
        increased_damage(increased_damage),
        direction(direction)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Bullet(const Bullet&) = default;
    Bullet& operator=(const Bullet&) = default;
#endif

    /**
     * Projectile speed.
     */
    ::Ice::Double speed;
    /**
     * The variable stores information whether the bullet collided with something.
     */
    bool collide;
    /**
     * The variable stores information whether the bullet has increased damage.
     * Increased damage allows you to destroy stone walls and bushes.
     */
    bool increased_damage;
    /**
     * The direction of the bullet's movement.
     */
    ::Acme::Direction direction;
};

/// \cond INTERNAL
inline bool operator==(const Bullet& lhs, const Bullet& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Bullet& lhs, const Bullet& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief An eagle class that players must defend and opponents must destroy.
 */
class Eagle : virtual public BaseObject
{
public:

    typedef EaglePtr PointerType;

    virtual ~Eagle();

    Eagle()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     */
    Eagle(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Eagle(const Eagle&) = default;
    Eagle& operator=(const Eagle&) = default;
#endif
};

/// \cond INTERNAL
inline bool operator==(const Eagle& lhs, const Eagle& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Eagle& lhs, const Eagle& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

class Bullet2 : public virtual ::Ice::LocalObject
{
public:

    typedef Bullet2Ptr PointerType;

    virtual ~Bullet2();

    Bullet2()
    {
    }

#ifdef ICE_CPP11_COMPILER
    Bullet2(const Bullet2&) = default;
    Bullet2& operator=(const Bullet2&) = default;
#endif
};

/// \cond INTERNAL
inline bool operator==(const Bullet2& lhs, const Bullet2& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Bullet2& lhs, const Bullet2& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

class BulletMix2 : public virtual ::Ice::LocalObject
{
public:

    typedef BulletMix2Ptr PointerType;

    virtual ~BulletMix2();

#ifdef ICE_CPP11_COMPILER
    BulletMix2() = default;
    BulletMix2(const BulletMix2&) = default;
    BulletMix2& operator=(const BulletMix2&) = default;
#endif

    virtual Bullet2Ptr get() = 0;

    virtual void set(const Bullet2Ptr& bullet) = 0;
};

/// \cond INTERNAL
inline bool operator==(const BulletMix2& lhs, const BulletMix2& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const BulletMix2& lhs, const BulletMix2& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief
 * A class dealing with basic tank mechanics: driving, shooting.
 */
class Tank : virtual public BaseObject
{
public:

    typedef TankPtr PointerType;

    virtual ~Tank();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    Tank() :
        m_flags(TSF_DEFAULT)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     */
    Tank(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Acme::TankStateFlag m_flags, ::Ice::Int m_slip_time, ::Acme::Direction new_direction, ::Ice::Int m_bullet_max_size, ::Ice::Int m_shield_time, ::Ice::Int m_frozen_time, ::Ice::Double default_speed, ::Ice::Double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, ::Ice::Int lives_count) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        m_flags(m_flags),
        m_slip_time(m_slip_time),
        new_direction(new_direction),
        m_bullet_max_size(m_bullet_max_size),
        m_shield_time(m_shield_time),
        m_frozen_time(m_frozen_time),
        default_speed(default_speed),
        speed(speed),
        stop(stop),
        direction(direction),
        bullets(bullets),
        lives_count(lives_count)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Tank(const Tank&) = default;
    Tank& operator=(const Tank&) = default;
#endif

protected:

    /**
     * Flags that the tank currently has.
     */
    ::Acme::TankStateFlag m_flags;
    /**
     * Time since slippage occurred.
     */
    ::Ice::Int m_slip_time;
    /**
     * Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     */
    ::Acme::Direction new_direction;
    /**
     * The maximum number of bullets that the tank can fire.
     */
    ::Ice::Int m_bullet_max_size;
    /**
     * Time since gaining cover.
     */
    ::Ice::Int m_shield_time;
    /**
     * Time since the tank was frozen.
     */
    ::Ice::Int m_frozen_time;

public:

    /**
     * Default speed of a given tank. It may be different for different types of tanks or may be changed after the player takes the bonus.
     */
    ::Ice::Double default_speed;
    /**
     * Current tank speed.
     */
    ::Ice::Double speed;
    /**
     * The variable stores information whether the tank is currently stopped.
     */
    bool stop;
    /**
     * Variable stores the current driving direction of the tank.
     */
    ::Acme::Direction direction;
    /**
     * Container with fired tank missiles.
     */
    ::Acme::BulletSequence2 bullets;
    /**
     * The number of player lives or the armor level number of the enemy tank.
     */
    ::Ice::Int lives_count;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const Tank& lhs, const Tank& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Tank& lhs, const Tank& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief Class dealing with enemy tank movements.
 */
class Enemy : virtual public Tank
{
public:

    typedef EnemyPtr PointerType;

    virtual ~Enemy();

    Enemy()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     * @param m_direction_time Time since last change of direction.
     * @param m_keep_direction_time Driving time in a given direction.
     * @param m_speed_time Time since last attempt to resume driving
     * @param m_try_to_go_time Time after which the next resumption of driving will occur; non-zero speed setting.
     * @param m_fire_time Time since the last missile launch attempt.
     * @param m_reload_time The time after which another shot will be attempted.
     * @param target_position The position to which the enemy tank is heading.
     */
    Enemy(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Acme::TankStateFlag m_flags, ::Ice::Int m_slip_time, ::Acme::Direction new_direction, ::Ice::Int m_bullet_max_size, ::Ice::Int m_shield_time, ::Ice::Int m_frozen_time, ::Ice::Double default_speed, ::Ice::Double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, ::Ice::Int lives_count, ::Ice::Int m_direction_time, ::Ice::Int m_keep_direction_time, ::Ice::Int m_speed_time, ::Ice::Int m_try_to_go_time, ::Ice::Int m_fire_time, ::Ice::Int m_reload_time, const ::Acme::SDL_Point& target_position) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        ::Acme::Tank(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y, m_flags, m_slip_time, new_direction, m_bullet_max_size, m_shield_time, m_frozen_time, default_speed, speed, stop, direction, bullets, lives_count),
        m_direction_time(m_direction_time),
        m_keep_direction_time(m_keep_direction_time),
        m_speed_time(m_speed_time),
        m_try_to_go_time(m_try_to_go_time),
        m_fire_time(m_fire_time),
        m_reload_time(m_reload_time),
        target_position(target_position)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Enemy(const Enemy&) = default;
    Enemy& operator=(const Enemy&) = default;
#endif

protected:

    /**
     * Time since last change of direction.
     */
    ::Ice::Int m_direction_time;
    /**
     * Driving time in a given direction. The time after which the direction will change.
     */
    ::Ice::Int m_keep_direction_time;
    /**
     * Time since last attempt to resume driving
     */
    ::Ice::Int m_speed_time;
    /**
     * Time after which the next resumption of driving will occur; non-zero speed setting.
     */
    ::Ice::Int m_try_to_go_time;
    /**
     * Time since the last missile launch attempt.
     */
    ::Ice::Int m_fire_time;
    /**
     * The time after which another shot will be attempted.
     */
    ::Ice::Int m_reload_time;

public:

    /**
     * The position to which the enemy tank is heading.
     */
    ::Acme::SDL_Point target_position;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const Enemy& lhs, const Enemy& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Enemy& lhs, const Enemy& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

/**
 * @brief Class corresponding to player tanks.
 */
class Player : virtual public Tank
{
public:

    typedef PlayerPtr PointerType;

    virtual ~Player();

    /** Default constructor that assigns default values to members as specified in the Slice definition. */
    Player() :
        star_count(0),
        m_fire_time(0),
        m_movement(false),
        m_menu(false)
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     * @param m_frame_display_time Display time of the current animation frame.
     * @param m_current_frame Number of the current animation frame.
     * @param to_erase The variable says whether the object should be deleted.
     * @param collision_rect Collision rectangle; may be smaller than the dimensions of dest_rect.
     * @param dest_rect The target position of the object on the screen.
     * @param src_rect Position on the texture of the currently displayed frame.
     * @param type BaseObject type.
     * @param pos_x Accurate horizontal position of the object.
     * @param pos_y Accurate vertical position of the object.
     * @param m_flags Flags that the tank currently has.
     * @param m_slip_time Time since slippage occurred.
     * @param new_direction Corresponds to the direction of the tank in skidding and may be different from the direction of movement of the tank on ice.
     * @param m_bullet_max_size The maximum number of bullets that the tank can fire.
     * @param m_shield_time Time since gaining cover.
     * @param m_frozen_time Time since the tank was frozen.
     * @param default_speed Default speed of a given tank.
     * @param speed Current tank speed.
     * @param stop The variable stores information whether the tank is currently stopped.
     * @param direction Variable stores the current driving direction of the tank.
     * @param bullets Container with fired tank missiles.
     * @param lives_count The number of player lives or the armor level number of the enemy tank.
     * @param star_count Current number of stars; may be in the range [0, 3].
     * @param m_fire_time The time that has passed since the last missile shot.
     * @param m_movement Machine is in movement.
     * @param m_menu It is menu tank.
     * @param score The player's current points.
     */
    Player(::Ice::Int m_frame_display_time, ::Ice::Int m_current_frame, bool to_erase, const ::Acme::SDL_Rect& collision_rect, const ::Acme::SDL_Rect& dest_rect, const ::Acme::SDL_Rect& src_rect, ::Acme::SpriteType type, ::Ice::Double pos_x, ::Ice::Double pos_y, ::Acme::TankStateFlag m_flags, ::Ice::Int m_slip_time, ::Acme::Direction new_direction, ::Ice::Int m_bullet_max_size, ::Ice::Int m_shield_time, ::Ice::Int m_frozen_time, ::Ice::Double default_speed, ::Ice::Double speed, bool stop, ::Acme::Direction direction, const ::Acme::BulletSequence2& bullets, ::Ice::Int lives_count, ::Ice::Int star_count, ::Ice::Int m_fire_time, bool m_movement, bool m_menu, ::Ice::Int score) :
        ::Acme::BaseObject(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y),
        ::Acme::Tank(m_frame_display_time, m_current_frame, to_erase, collision_rect, dest_rect, src_rect, type, pos_x, pos_y, m_flags, m_slip_time, new_direction, m_bullet_max_size, m_shield_time, m_frozen_time, default_speed, speed, stop, direction, bullets, lives_count),
        star_count(star_count),
        m_fire_time(m_fire_time),
        m_movement(m_movement),
        m_menu(m_menu),
        score(score)
    {
    }

#ifdef ICE_CPP11_COMPILER
    Player(const Player&) = default;
    Player& operator=(const Player&) = default;
#endif

protected:

    /**
     * Current number of stars; may be in the range [0, 3].
     */
    ::Ice::Int star_count;
    /**
     * The time that has passed since the last missile shot.
     */
    ::Ice::Int m_fire_time;
    /**
     * Machine is in movement.
     */
    bool m_movement;
    /**
     * It is menu tank.
     */
    bool m_menu;

public:

    /**
     * The player's current points.
     */
    ::Ice::Int score;

protected:

    template<typename T, typename S>
    friend struct Ice::StreamWriter;
    template<typename T, typename S>
    friend struct Ice::StreamReader;
};

/// \cond INTERNAL
inline bool operator==(const Player& lhs, const Player& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) == static_cast<const ::Ice::LocalObject&>(rhs);
}

inline bool operator<(const Player& lhs, const Player& rhs)
{
    return static_cast<const ::Ice::LocalObject&>(lhs) < static_cast<const ::Ice::LocalObject&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Acme::SDL_Rect>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Acme::SDL_Rect, S>
{
    static void write(S* ostr, const ::Acme::SDL_Rect& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.w);
        ostr->write(v.h);
    }
};

template<typename S>
struct StreamReader< ::Acme::SDL_Rect, S>
{
    static void read(S* istr, ::Acme::SDL_Rect& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.w);
        istr->read(v.h);
    }
};

template<>
struct StreamableTraits< ::Acme::SDL_Point>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 8;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::Acme::SDL_Point, S>
{
    static void write(S* ostr, const ::Acme::SDL_Point& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
    }
};

template<typename S>
struct StreamReader< ::Acme::SDL_Point, S>
{
    static void read(S* istr, ::Acme::SDL_Point& v)
    {
        istr->read(v.x);
        istr->read(v.y);
    }
};

template<>
struct StreamableTraits< ::Acme::Direction>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Acme::TankStateFlag>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 512;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::Acme::SpriteType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 32;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}
/// \endcond

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
