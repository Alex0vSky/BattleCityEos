// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acme.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_acme_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_acme_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_acme_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_acme_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_acme_2eproto;
namespace A0S_proto {
class Enemy;
struct EnemyDefaultTypeInternal;
extern EnemyDefaultTypeInternal _Enemy_default_instance_;
class Object;
struct ObjectDefaultTypeInternal;
extern ObjectDefaultTypeInternal _Object_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class SDL_Point;
struct SDL_PointDefaultTypeInternal;
extern SDL_PointDefaultTypeInternal _SDL_Point_default_instance_;
class SDL_Rect;
struct SDL_RectDefaultTypeInternal;
extern SDL_RectDefaultTypeInternal _SDL_Rect_default_instance_;
class Tank;
struct TankDefaultTypeInternal;
extern TankDefaultTypeInternal _Tank_default_instance_;
}  // namespace A0S_proto
PROTOBUF_NAMESPACE_OPEN
template <>
::A0S_proto::Enemy* Arena::CreateMaybeMessage<::A0S_proto::Enemy>(Arena*);
template <>
::A0S_proto::Object* Arena::CreateMaybeMessage<::A0S_proto::Object>(Arena*);
template <>
::A0S_proto::Player* Arena::CreateMaybeMessage<::A0S_proto::Player>(Arena*);
template <>
::A0S_proto::SDL_Point* Arena::CreateMaybeMessage<::A0S_proto::SDL_Point>(Arena*);
template <>
::A0S_proto::SDL_Rect* Arena::CreateMaybeMessage<::A0S_proto::SDL_Rect>(Arena*);
template <>
::A0S_proto::Tank* Arena::CreateMaybeMessage<::A0S_proto::Tank>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace A0S_proto {
enum SpriteType : int {
  ST_TANK_A = 0,
  ST_TANK_B = 1,
  ST_TANK_C = 2,
  SpriteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SpriteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SpriteType_IsValid(int value);
constexpr SpriteType SpriteType_MIN = static_cast<SpriteType>(0);
constexpr SpriteType SpriteType_MAX = static_cast<SpriteType>(2);
constexpr int SpriteType_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SpriteType_descriptor();
template <typename T>
const std::string& SpriteType_Name(T value) {
  static_assert(std::is_same<T, SpriteType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SpriteType_Name().");
  return SpriteType_Name(static_cast<SpriteType>(value));
}
template <>
inline const std::string& SpriteType_Name(SpriteType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SpriteType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SpriteType_Parse(absl::string_view name, SpriteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpriteType>(
      SpriteType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SDL_Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.SDL_Rect) */ {
 public:
  inline SDL_Rect() : SDL_Rect(nullptr) {}
  ~SDL_Rect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SDL_Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SDL_Rect(const SDL_Rect& from);
  SDL_Rect(SDL_Rect&& from) noexcept
    : SDL_Rect() {
    *this = ::std::move(from);
  }

  inline SDL_Rect& operator=(const SDL_Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline SDL_Rect& operator=(SDL_Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SDL_Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const SDL_Rect* internal_default_instance() {
    return reinterpret_cast<const SDL_Rect*>(
               &_SDL_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SDL_Rect& a, SDL_Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(SDL_Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SDL_Rect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SDL_Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SDL_Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SDL_Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SDL_Rect& from) {
    SDL_Rect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SDL_Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.SDL_Rect";
  }
  protected:
  explicit SDL_Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWFieldNumber = 3,
    kHFieldNumber = 5,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // int32 w = 3;
  void clear_w() ;
  ::int32_t w() const;
  void set_w(::int32_t value);

  private:
  ::int32_t _internal_w() const;
  void _internal_set_w(::int32_t value);

  public:
  // int32 h = 5;
  void clear_h() ;
  ::int32_t h() const;
  void set_h(::int32_t value);

  private:
  ::int32_t _internal_h() const;
  void _internal_set_h(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.SDL_Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x_;
    ::int32_t y_;
    ::int32_t w_;
    ::int32_t h_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};// -------------------------------------------------------------------

class Object final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.Object) */ {
 public:
  inline Object() : Object(nullptr) {}
  ~Object() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Object(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Object(const Object& from);
  Object(Object&& from) noexcept
    : Object() {
    *this = ::std::move(from);
  }

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }
  inline Object& operator=(Object&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Object& default_instance() {
    return *internal_default_instance();
  }
  static inline const Object* internal_default_instance() {
    return reinterpret_cast<const Object*>(
               &_Object_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Object& a, Object& b) {
    a.Swap(&b);
  }
  inline void Swap(Object* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Object* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Object* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Object>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Object& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Object& from) {
    Object::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Object* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.Object";
  }
  protected:
  explicit Object(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollisionRectFieldNumber = 4,
    kDestRectFieldNumber = 5,
    kSrcRectFieldNumber = 6,
    kFrameDisplayTimeFieldNumber = 1,
    kCurrentFrameFieldNumber = 2,
    kToEraseFieldNumber = 3,
    kTypeFieldNumber = 7,
    kPosXFieldNumber = 8,
    kPosYFieldNumber = 9,
  };
  // .A0S_proto.SDL_Rect collision_rect = 4;
  bool has_collision_rect() const;
  void clear_collision_rect() ;
  const ::A0S_proto::SDL_Rect& collision_rect() const;
  PROTOBUF_NODISCARD ::A0S_proto::SDL_Rect* release_collision_rect();
  ::A0S_proto::SDL_Rect* mutable_collision_rect();
  void set_allocated_collision_rect(::A0S_proto::SDL_Rect* collision_rect);
  private:
  const ::A0S_proto::SDL_Rect& _internal_collision_rect() const;
  ::A0S_proto::SDL_Rect* _internal_mutable_collision_rect();
  public:
  void unsafe_arena_set_allocated_collision_rect(
      ::A0S_proto::SDL_Rect* collision_rect);
  ::A0S_proto::SDL_Rect* unsafe_arena_release_collision_rect();
  // .A0S_proto.SDL_Rect dest_rect = 5;
  bool has_dest_rect() const;
  void clear_dest_rect() ;
  const ::A0S_proto::SDL_Rect& dest_rect() const;
  PROTOBUF_NODISCARD ::A0S_proto::SDL_Rect* release_dest_rect();
  ::A0S_proto::SDL_Rect* mutable_dest_rect();
  void set_allocated_dest_rect(::A0S_proto::SDL_Rect* dest_rect);
  private:
  const ::A0S_proto::SDL_Rect& _internal_dest_rect() const;
  ::A0S_proto::SDL_Rect* _internal_mutable_dest_rect();
  public:
  void unsafe_arena_set_allocated_dest_rect(
      ::A0S_proto::SDL_Rect* dest_rect);
  ::A0S_proto::SDL_Rect* unsafe_arena_release_dest_rect();
  // .A0S_proto.SDL_Rect src_rect = 6;
  bool has_src_rect() const;
  void clear_src_rect() ;
  const ::A0S_proto::SDL_Rect& src_rect() const;
  PROTOBUF_NODISCARD ::A0S_proto::SDL_Rect* release_src_rect();
  ::A0S_proto::SDL_Rect* mutable_src_rect();
  void set_allocated_src_rect(::A0S_proto::SDL_Rect* src_rect);
  private:
  const ::A0S_proto::SDL_Rect& _internal_src_rect() const;
  ::A0S_proto::SDL_Rect* _internal_mutable_src_rect();
  public:
  void unsafe_arena_set_allocated_src_rect(
      ::A0S_proto::SDL_Rect* src_rect);
  ::A0S_proto::SDL_Rect* unsafe_arena_release_src_rect();
  // uint32 frame_display_time = 1;
  void clear_frame_display_time() ;
  ::uint32_t frame_display_time() const;
  void set_frame_display_time(::uint32_t value);

  private:
  ::uint32_t _internal_frame_display_time() const;
  void _internal_set_frame_display_time(::uint32_t value);

  public:
  // int32 current_frame = 2;
  void clear_current_frame() ;
  ::int32_t current_frame() const;
  void set_current_frame(::int32_t value);

  private:
  ::int32_t _internal_current_frame() const;
  void _internal_set_current_frame(::int32_t value);

  public:
  // bool to_erase = 3;
  void clear_to_erase() ;
  bool to_erase() const;
  void set_to_erase(bool value);

  private:
  bool _internal_to_erase() const;
  void _internal_set_to_erase(bool value);

  public:
  // uint32 type = 7;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // double pos_x = 8;
  void clear_pos_x() ;
  double pos_x() const;
  void set_pos_x(double value);

  private:
  double _internal_pos_x() const;
  void _internal_set_pos_x(double value);

  public:
  // double pos_y = 9;
  void clear_pos_y() ;
  double pos_y() const;
  void set_pos_y(double value);

  private:
  double _internal_pos_y() const;
  void _internal_set_pos_y(double value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.Object)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::A0S_proto::SDL_Rect* collision_rect_;
    ::A0S_proto::SDL_Rect* dest_rect_;
    ::A0S_proto::SDL_Rect* src_rect_;
    ::uint32_t frame_display_time_;
    ::int32_t current_frame_;
    bool to_erase_;
    ::uint32_t type_;
    double pos_x_;
    double pos_y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};// -------------------------------------------------------------------

class Tank final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.Tank) */ {
 public:
  inline Tank() : Tank(nullptr) {}
  ~Tank() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tank(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tank(const Tank& from);
  Tank(Tank&& from) noexcept
    : Tank() {
    *this = ::std::move(from);
  }

  inline Tank& operator=(const Tank& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tank& operator=(Tank&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tank& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tank* internal_default_instance() {
    return reinterpret_cast<const Tank*>(
               &_Tank_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Tank& a, Tank& b) {
    a.Swap(&b);
  }
  inline void Swap(Tank* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tank* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tank* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tank>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tank& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tank& from) {
    Tank::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tank* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.Tank";
  }
  protected:
  explicit Tank(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kSlipTimeFieldNumber = 3,
    kNewDirectionFieldNumber = 4,
    kBulletMaxSizeFieldNumber = 5,
    kDefaultSpeedFieldNumber = 6,
  };
  // .A0S_proto.Object object = 1;
  bool has_object() const;
  void clear_object() ;
  const ::A0S_proto::Object& object() const;
  PROTOBUF_NODISCARD ::A0S_proto::Object* release_object();
  ::A0S_proto::Object* mutable_object();
  void set_allocated_object(::A0S_proto::Object* object);
  private:
  const ::A0S_proto::Object& _internal_object() const;
  ::A0S_proto::Object* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::A0S_proto::Object* object);
  ::A0S_proto::Object* unsafe_arena_release_object();
  // int32 flags = 2;
  void clear_flags() ;
  ::int32_t flags() const;
  void set_flags(::int32_t value);

  private:
  ::int32_t _internal_flags() const;
  void _internal_set_flags(::int32_t value);

  public:
  // int32 slip_time = 3;
  void clear_slip_time() ;
  ::int32_t slip_time() const;
  void set_slip_time(::int32_t value);

  private:
  ::int32_t _internal_slip_time() const;
  void _internal_set_slip_time(::int32_t value);

  public:
  // int32 new_direction = 4;
  void clear_new_direction() ;
  ::int32_t new_direction() const;
  void set_new_direction(::int32_t value);

  private:
  ::int32_t _internal_new_direction() const;
  void _internal_set_new_direction(::int32_t value);

  public:
  // uint32 bullet_max_size = 5;
  void clear_bullet_max_size() ;
  ::uint32_t bullet_max_size() const;
  void set_bullet_max_size(::uint32_t value);

  private:
  ::uint32_t _internal_bullet_max_size() const;
  void _internal_set_bullet_max_size(::uint32_t value);

  public:
  // double default_speed = 6;
  void clear_default_speed() ;
  double default_speed() const;
  void set_default_speed(double value);

  private:
  double _internal_default_speed() const;
  void _internal_set_default_speed(double value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.Tank)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::A0S_proto::Object* object_;
    ::int32_t flags_;
    ::int32_t slip_time_;
    ::int32_t new_direction_;
    ::uint32_t bullet_max_size_;
    double default_speed_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTankFieldNumber = 1,
    kStarCountFieldNumber = 2,
    kFireTimeFieldNumber = 3,
    kMovementFieldNumber = 4,
    kMenuFieldNumber = 5,
  };
  // .A0S_proto.Tank tank = 1;
  bool has_tank() const;
  void clear_tank() ;
  const ::A0S_proto::Tank& tank() const;
  PROTOBUF_NODISCARD ::A0S_proto::Tank* release_tank();
  ::A0S_proto::Tank* mutable_tank();
  void set_allocated_tank(::A0S_proto::Tank* tank);
  private:
  const ::A0S_proto::Tank& _internal_tank() const;
  ::A0S_proto::Tank* _internal_mutable_tank();
  public:
  void unsafe_arena_set_allocated_tank(
      ::A0S_proto::Tank* tank);
  ::A0S_proto::Tank* unsafe_arena_release_tank();
  // int32 star_count = 2;
  void clear_star_count() ;
  ::int32_t star_count() const;
  void set_star_count(::int32_t value);

  private:
  ::int32_t _internal_star_count() const;
  void _internal_set_star_count(::int32_t value);

  public:
  // int32 fire_time = 3;
  void clear_fire_time() ;
  ::int32_t fire_time() const;
  void set_fire_time(::int32_t value);

  private:
  ::int32_t _internal_fire_time() const;
  void _internal_set_fire_time(::int32_t value);

  public:
  // bool movement = 4;
  void clear_movement() ;
  bool movement() const;
  void set_movement(bool value);

  private:
  bool _internal_movement() const;
  void _internal_set_movement(bool value);

  public:
  // bool menu = 5;
  void clear_menu() ;
  bool menu() const;
  void set_menu(bool value);

  private:
  bool _internal_menu() const;
  void _internal_set_menu(bool value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::A0S_proto::Tank* tank_;
    ::int32_t star_count_;
    ::int32_t fire_time_;
    bool movement_;
    bool menu_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};// -------------------------------------------------------------------

class SDL_Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.SDL_Point) */ {
 public:
  inline SDL_Point() : SDL_Point(nullptr) {}
  ~SDL_Point() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SDL_Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SDL_Point(const SDL_Point& from);
  SDL_Point(SDL_Point&& from) noexcept
    : SDL_Point() {
    *this = ::std::move(from);
  }

  inline SDL_Point& operator=(const SDL_Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline SDL_Point& operator=(SDL_Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SDL_Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const SDL_Point* internal_default_instance() {
    return reinterpret_cast<const SDL_Point*>(
               &_SDL_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SDL_Point& a, SDL_Point& b) {
    a.Swap(&b);
  }
  inline void Swap(SDL_Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SDL_Point* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SDL_Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SDL_Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SDL_Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SDL_Point& from) {
    SDL_Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SDL_Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.SDL_Point";
  }
  protected:
  explicit SDL_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.SDL_Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t x_;
    ::int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};// -------------------------------------------------------------------

class Enemy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:A0S_proto.Enemy) */ {
 public:
  inline Enemy() : Enemy(nullptr) {}
  ~Enemy() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Enemy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Enemy(const Enemy& from);
  Enemy(Enemy&& from) noexcept
    : Enemy() {
    *this = ::std::move(from);
  }

  inline Enemy& operator=(const Enemy& from) {
    CopyFrom(from);
    return *this;
  }
  inline Enemy& operator=(Enemy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Enemy& default_instance() {
    return *internal_default_instance();
  }
  static inline const Enemy* internal_default_instance() {
    return reinterpret_cast<const Enemy*>(
               &_Enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Enemy& a, Enemy& b) {
    a.Swap(&b);
  }
  inline void Swap(Enemy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Enemy* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Enemy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Enemy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Enemy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Enemy& from) {
    Enemy::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enemy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "A0S_proto.Enemy";
  }
  protected:
  explicit Enemy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTankFieldNumber = 1,
    kTargetPositionFieldNumber = 8,
    kDirectionTimeFieldNumber = 2,
    kKeepDirectionTimeFieldNumber = 3,
    kSpeedTimeFieldNumber = 4,
    kTryToGoTimeFieldNumber = 5,
    kFireTimeFieldNumber = 6,
    kReloadTimeFieldNumber = 7,
  };
  // .A0S_proto.Tank tank = 1;
  bool has_tank() const;
  void clear_tank() ;
  const ::A0S_proto::Tank& tank() const;
  PROTOBUF_NODISCARD ::A0S_proto::Tank* release_tank();
  ::A0S_proto::Tank* mutable_tank();
  void set_allocated_tank(::A0S_proto::Tank* tank);
  private:
  const ::A0S_proto::Tank& _internal_tank() const;
  ::A0S_proto::Tank* _internal_mutable_tank();
  public:
  void unsafe_arena_set_allocated_tank(
      ::A0S_proto::Tank* tank);
  ::A0S_proto::Tank* unsafe_arena_release_tank();
  // .A0S_proto.SDL_Point target_position = 8;
  bool has_target_position() const;
  void clear_target_position() ;
  const ::A0S_proto::SDL_Point& target_position() const;
  PROTOBUF_NODISCARD ::A0S_proto::SDL_Point* release_target_position();
  ::A0S_proto::SDL_Point* mutable_target_position();
  void set_allocated_target_position(::A0S_proto::SDL_Point* target_position);
  private:
  const ::A0S_proto::SDL_Point& _internal_target_position() const;
  ::A0S_proto::SDL_Point* _internal_mutable_target_position();
  public:
  void unsafe_arena_set_allocated_target_position(
      ::A0S_proto::SDL_Point* target_position);
  ::A0S_proto::SDL_Point* unsafe_arena_release_target_position();
  // uint32 direction_time = 2;
  void clear_direction_time() ;
  ::uint32_t direction_time() const;
  void set_direction_time(::uint32_t value);

  private:
  ::uint32_t _internal_direction_time() const;
  void _internal_set_direction_time(::uint32_t value);

  public:
  // uint32 keep_direction_time = 3;
  void clear_keep_direction_time() ;
  ::uint32_t keep_direction_time() const;
  void set_keep_direction_time(::uint32_t value);

  private:
  ::uint32_t _internal_keep_direction_time() const;
  void _internal_set_keep_direction_time(::uint32_t value);

  public:
  // uint32 speed_time = 4;
  void clear_speed_time() ;
  ::uint32_t speed_time() const;
  void set_speed_time(::uint32_t value);

  private:
  ::uint32_t _internal_speed_time() const;
  void _internal_set_speed_time(::uint32_t value);

  public:
  // uint32 try_to_go_time = 5;
  void clear_try_to_go_time() ;
  ::uint32_t try_to_go_time() const;
  void set_try_to_go_time(::uint32_t value);

  private:
  ::uint32_t _internal_try_to_go_time() const;
  void _internal_set_try_to_go_time(::uint32_t value);

  public:
  // uint32 fire_time = 6;
  void clear_fire_time() ;
  ::uint32_t fire_time() const;
  void set_fire_time(::uint32_t value);

  private:
  ::uint32_t _internal_fire_time() const;
  void _internal_set_fire_time(::uint32_t value);

  public:
  // uint32 reload_time = 7;
  void clear_reload_time() ;
  ::uint32_t reload_time() const;
  void set_reload_time(::uint32_t value);

  private:
  ::uint32_t _internal_reload_time() const;
  void _internal_set_reload_time(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:A0S_proto.Enemy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::A0S_proto::Tank* tank_;
    ::A0S_proto::SDL_Point* target_position_;
    ::uint32_t direction_time_;
    ::uint32_t keep_direction_time_;
    ::uint32_t speed_time_;
    ::uint32_t try_to_go_time_;
    ::uint32_t fire_time_;
    ::uint32_t reload_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_acme_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SDL_Rect

// int32 x = 1;
inline void SDL_Rect::clear_x() {
  _impl_.x_ = 0;
}
inline ::int32_t SDL_Rect::x() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Rect.x)
  return _internal_x();
}
inline void SDL_Rect::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Rect.x)
}
inline ::int32_t SDL_Rect::_internal_x() const {
  return _impl_.x_;
}
inline void SDL_Rect::_internal_set_x(::int32_t value) {
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void SDL_Rect::clear_y() {
  _impl_.y_ = 0;
}
inline ::int32_t SDL_Rect::y() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Rect.y)
  return _internal_y();
}
inline void SDL_Rect::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Rect.y)
}
inline ::int32_t SDL_Rect::_internal_y() const {
  return _impl_.y_;
}
inline void SDL_Rect::_internal_set_y(::int32_t value) {
  ;
  _impl_.y_ = value;
}

// int32 w = 3;
inline void SDL_Rect::clear_w() {
  _impl_.w_ = 0;
}
inline ::int32_t SDL_Rect::w() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Rect.w)
  return _internal_w();
}
inline void SDL_Rect::set_w(::int32_t value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Rect.w)
}
inline ::int32_t SDL_Rect::_internal_w() const {
  return _impl_.w_;
}
inline void SDL_Rect::_internal_set_w(::int32_t value) {
  ;
  _impl_.w_ = value;
}

// int32 h = 5;
inline void SDL_Rect::clear_h() {
  _impl_.h_ = 0;
}
inline ::int32_t SDL_Rect::h() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Rect.h)
  return _internal_h();
}
inline void SDL_Rect::set_h(::int32_t value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Rect.h)
}
inline ::int32_t SDL_Rect::_internal_h() const {
  return _impl_.h_;
}
inline void SDL_Rect::_internal_set_h(::int32_t value) {
  ;
  _impl_.h_ = value;
}

// -------------------------------------------------------------------

// Object

// uint32 frame_display_time = 1;
inline void Object::clear_frame_display_time() {
  _impl_.frame_display_time_ = 0u;
}
inline ::uint32_t Object::frame_display_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.frame_display_time)
  return _internal_frame_display_time();
}
inline void Object::set_frame_display_time(::uint32_t value) {
  _internal_set_frame_display_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.frame_display_time)
}
inline ::uint32_t Object::_internal_frame_display_time() const {
  return _impl_.frame_display_time_;
}
inline void Object::_internal_set_frame_display_time(::uint32_t value) {
  ;
  _impl_.frame_display_time_ = value;
}

// int32 current_frame = 2;
inline void Object::clear_current_frame() {
  _impl_.current_frame_ = 0;
}
inline ::int32_t Object::current_frame() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.current_frame)
  return _internal_current_frame();
}
inline void Object::set_current_frame(::int32_t value) {
  _internal_set_current_frame(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.current_frame)
}
inline ::int32_t Object::_internal_current_frame() const {
  return _impl_.current_frame_;
}
inline void Object::_internal_set_current_frame(::int32_t value) {
  ;
  _impl_.current_frame_ = value;
}

// bool to_erase = 3;
inline void Object::clear_to_erase() {
  _impl_.to_erase_ = false;
}
inline bool Object::to_erase() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.to_erase)
  return _internal_to_erase();
}
inline void Object::set_to_erase(bool value) {
  _internal_set_to_erase(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.to_erase)
}
inline bool Object::_internal_to_erase() const {
  return _impl_.to_erase_;
}
inline void Object::_internal_set_to_erase(bool value) {
  ;
  _impl_.to_erase_ = value;
}

// .A0S_proto.SDL_Rect collision_rect = 4;
inline bool Object::has_collision_rect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.collision_rect_ != nullptr);
  return value;
}
inline void Object::clear_collision_rect() {
  if (_impl_.collision_rect_ != nullptr) _impl_.collision_rect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::A0S_proto::SDL_Rect& Object::_internal_collision_rect() const {
  const ::A0S_proto::SDL_Rect* p = _impl_.collision_rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::SDL_Rect&>(
      ::A0S_proto::_SDL_Rect_default_instance_);
}
inline const ::A0S_proto::SDL_Rect& Object::collision_rect() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.collision_rect)
  return _internal_collision_rect();
}
inline void Object::unsafe_arena_set_allocated_collision_rect(
    ::A0S_proto::SDL_Rect* collision_rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collision_rect_);
  }
  _impl_.collision_rect_ = collision_rect;
  if (collision_rect) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Object.collision_rect)
}
inline ::A0S_proto::SDL_Rect* Object::release_collision_rect() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::SDL_Rect* temp = _impl_.collision_rect_;
  _impl_.collision_rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::unsafe_arena_release_collision_rect() {
  // @@protoc_insertion_point(field_release:A0S_proto.Object.collision_rect)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::SDL_Rect* temp = _impl_.collision_rect_;
  _impl_.collision_rect_ = nullptr;
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::_internal_mutable_collision_rect() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.collision_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::SDL_Rect>(GetArenaForAllocation());
    _impl_.collision_rect_ = p;
  }
  return _impl_.collision_rect_;
}
inline ::A0S_proto::SDL_Rect* Object::mutable_collision_rect() {
  ::A0S_proto::SDL_Rect* _msg = _internal_mutable_collision_rect();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Object.collision_rect)
  return _msg;
}
inline void Object::set_allocated_collision_rect(::A0S_proto::SDL_Rect* collision_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.collision_rect_;
  }
  if (collision_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collision_rect);
    if (message_arena != submessage_arena) {
      collision_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collision_rect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.collision_rect_ = collision_rect;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Object.collision_rect)
}

// .A0S_proto.SDL_Rect dest_rect = 5;
inline bool Object::has_dest_rect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dest_rect_ != nullptr);
  return value;
}
inline void Object::clear_dest_rect() {
  if (_impl_.dest_rect_ != nullptr) _impl_.dest_rect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::A0S_proto::SDL_Rect& Object::_internal_dest_rect() const {
  const ::A0S_proto::SDL_Rect* p = _impl_.dest_rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::SDL_Rect&>(
      ::A0S_proto::_SDL_Rect_default_instance_);
}
inline const ::A0S_proto::SDL_Rect& Object::dest_rect() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.dest_rect)
  return _internal_dest_rect();
}
inline void Object::unsafe_arena_set_allocated_dest_rect(
    ::A0S_proto::SDL_Rect* dest_rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dest_rect_);
  }
  _impl_.dest_rect_ = dest_rect;
  if (dest_rect) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Object.dest_rect)
}
inline ::A0S_proto::SDL_Rect* Object::release_dest_rect() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::A0S_proto::SDL_Rect* temp = _impl_.dest_rect_;
  _impl_.dest_rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::unsafe_arena_release_dest_rect() {
  // @@protoc_insertion_point(field_release:A0S_proto.Object.dest_rect)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::A0S_proto::SDL_Rect* temp = _impl_.dest_rect_;
  _impl_.dest_rect_ = nullptr;
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::_internal_mutable_dest_rect() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.dest_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::SDL_Rect>(GetArenaForAllocation());
    _impl_.dest_rect_ = p;
  }
  return _impl_.dest_rect_;
}
inline ::A0S_proto::SDL_Rect* Object::mutable_dest_rect() {
  ::A0S_proto::SDL_Rect* _msg = _internal_mutable_dest_rect();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Object.dest_rect)
  return _msg;
}
inline void Object::set_allocated_dest_rect(::A0S_proto::SDL_Rect* dest_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dest_rect_;
  }
  if (dest_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dest_rect);
    if (message_arena != submessage_arena) {
      dest_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest_rect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dest_rect_ = dest_rect;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Object.dest_rect)
}

// .A0S_proto.SDL_Rect src_rect = 6;
inline bool Object::has_src_rect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_rect_ != nullptr);
  return value;
}
inline void Object::clear_src_rect() {
  if (_impl_.src_rect_ != nullptr) _impl_.src_rect_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::A0S_proto::SDL_Rect& Object::_internal_src_rect() const {
  const ::A0S_proto::SDL_Rect* p = _impl_.src_rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::SDL_Rect&>(
      ::A0S_proto::_SDL_Rect_default_instance_);
}
inline const ::A0S_proto::SDL_Rect& Object::src_rect() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.src_rect)
  return _internal_src_rect();
}
inline void Object::unsafe_arena_set_allocated_src_rect(
    ::A0S_proto::SDL_Rect* src_rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.src_rect_);
  }
  _impl_.src_rect_ = src_rect;
  if (src_rect) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Object.src_rect)
}
inline ::A0S_proto::SDL_Rect* Object::release_src_rect() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::A0S_proto::SDL_Rect* temp = _impl_.src_rect_;
  _impl_.src_rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::unsafe_arena_release_src_rect() {
  // @@protoc_insertion_point(field_release:A0S_proto.Object.src_rect)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::A0S_proto::SDL_Rect* temp = _impl_.src_rect_;
  _impl_.src_rect_ = nullptr;
  return temp;
}
inline ::A0S_proto::SDL_Rect* Object::_internal_mutable_src_rect() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.src_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::SDL_Rect>(GetArenaForAllocation());
    _impl_.src_rect_ = p;
  }
  return _impl_.src_rect_;
}
inline ::A0S_proto::SDL_Rect* Object::mutable_src_rect() {
  ::A0S_proto::SDL_Rect* _msg = _internal_mutable_src_rect();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Object.src_rect)
  return _msg;
}
inline void Object::set_allocated_src_rect(::A0S_proto::SDL_Rect* src_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.src_rect_;
  }
  if (src_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(src_rect);
    if (message_arena != submessage_arena) {
      src_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src_rect, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.src_rect_ = src_rect;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Object.src_rect)
}

// uint32 type = 7;
inline void Object::clear_type() {
  _impl_.type_ = 0u;
}
inline ::uint32_t Object::type() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.type)
  return _internal_type();
}
inline void Object::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.type)
}
inline ::uint32_t Object::_internal_type() const {
  return _impl_.type_;
}
inline void Object::_internal_set_type(::uint32_t value) {
  ;
  _impl_.type_ = value;
}

// double pos_x = 8;
inline void Object::clear_pos_x() {
  _impl_.pos_x_ = 0;
}
inline double Object::pos_x() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.pos_x)
  return _internal_pos_x();
}
inline void Object::set_pos_x(double value) {
  _internal_set_pos_x(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.pos_x)
}
inline double Object::_internal_pos_x() const {
  return _impl_.pos_x_;
}
inline void Object::_internal_set_pos_x(double value) {
  ;
  _impl_.pos_x_ = value;
}

// double pos_y = 9;
inline void Object::clear_pos_y() {
  _impl_.pos_y_ = 0;
}
inline double Object::pos_y() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Object.pos_y)
  return _internal_pos_y();
}
inline void Object::set_pos_y(double value) {
  _internal_set_pos_y(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Object.pos_y)
}
inline double Object::_internal_pos_y() const {
  return _impl_.pos_y_;
}
inline void Object::_internal_set_pos_y(double value) {
  ;
  _impl_.pos_y_ = value;
}

// -------------------------------------------------------------------

// Tank

// .A0S_proto.Object object = 1;
inline bool Tank::has_object() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
  return value;
}
inline void Tank::clear_object() {
  if (_impl_.object_ != nullptr) _impl_.object_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::A0S_proto::Object& Tank::_internal_object() const {
  const ::A0S_proto::Object* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::Object&>(
      ::A0S_proto::_Object_default_instance_);
}
inline const ::A0S_proto::Object& Tank::object() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.object)
  return _internal_object();
}
inline void Tank::unsafe_arena_set_allocated_object(
    ::A0S_proto::Object* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Tank.object)
}
inline ::A0S_proto::Object* Tank::release_object() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::Object* Tank::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:A0S_proto.Tank.object)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Object* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::A0S_proto::Object* Tank::_internal_mutable_object() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::Object>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::A0S_proto::Object* Tank::mutable_object() {
  ::A0S_proto::Object* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Tank.object)
  return _msg;
}
inline void Tank::set_allocated_object(::A0S_proto::Object* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Tank.object)
}

// int32 flags = 2;
inline void Tank::clear_flags() {
  _impl_.flags_ = 0;
}
inline ::int32_t Tank::flags() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.flags)
  return _internal_flags();
}
inline void Tank::set_flags(::int32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Tank.flags)
}
inline ::int32_t Tank::_internal_flags() const {
  return _impl_.flags_;
}
inline void Tank::_internal_set_flags(::int32_t value) {
  ;
  _impl_.flags_ = value;
}

// int32 slip_time = 3;
inline void Tank::clear_slip_time() {
  _impl_.slip_time_ = 0;
}
inline ::int32_t Tank::slip_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.slip_time)
  return _internal_slip_time();
}
inline void Tank::set_slip_time(::int32_t value) {
  _internal_set_slip_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Tank.slip_time)
}
inline ::int32_t Tank::_internal_slip_time() const {
  return _impl_.slip_time_;
}
inline void Tank::_internal_set_slip_time(::int32_t value) {
  ;
  _impl_.slip_time_ = value;
}

// int32 new_direction = 4;
inline void Tank::clear_new_direction() {
  _impl_.new_direction_ = 0;
}
inline ::int32_t Tank::new_direction() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.new_direction)
  return _internal_new_direction();
}
inline void Tank::set_new_direction(::int32_t value) {
  _internal_set_new_direction(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Tank.new_direction)
}
inline ::int32_t Tank::_internal_new_direction() const {
  return _impl_.new_direction_;
}
inline void Tank::_internal_set_new_direction(::int32_t value) {
  ;
  _impl_.new_direction_ = value;
}

// uint32 bullet_max_size = 5;
inline void Tank::clear_bullet_max_size() {
  _impl_.bullet_max_size_ = 0u;
}
inline ::uint32_t Tank::bullet_max_size() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.bullet_max_size)
  return _internal_bullet_max_size();
}
inline void Tank::set_bullet_max_size(::uint32_t value) {
  _internal_set_bullet_max_size(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Tank.bullet_max_size)
}
inline ::uint32_t Tank::_internal_bullet_max_size() const {
  return _impl_.bullet_max_size_;
}
inline void Tank::_internal_set_bullet_max_size(::uint32_t value) {
  ;
  _impl_.bullet_max_size_ = value;
}

// double default_speed = 6;
inline void Tank::clear_default_speed() {
  _impl_.default_speed_ = 0;
}
inline double Tank::default_speed() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Tank.default_speed)
  return _internal_default_speed();
}
inline void Tank::set_default_speed(double value) {
  _internal_set_default_speed(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Tank.default_speed)
}
inline double Tank::_internal_default_speed() const {
  return _impl_.default_speed_;
}
inline void Tank::_internal_set_default_speed(double value) {
  ;
  _impl_.default_speed_ = value;
}

// -------------------------------------------------------------------

// Player

// .A0S_proto.Tank tank = 1;
inline bool Player::has_tank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tank_ != nullptr);
  return value;
}
inline void Player::clear_tank() {
  if (_impl_.tank_ != nullptr) _impl_.tank_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::A0S_proto::Tank& Player::_internal_tank() const {
  const ::A0S_proto::Tank* p = _impl_.tank_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::Tank&>(
      ::A0S_proto::_Tank_default_instance_);
}
inline const ::A0S_proto::Tank& Player::tank() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Player.tank)
  return _internal_tank();
}
inline void Player::unsafe_arena_set_allocated_tank(
    ::A0S_proto::Tank* tank) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tank_);
  }
  _impl_.tank_ = tank;
  if (tank) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Player.tank)
}
inline ::A0S_proto::Tank* Player::release_tank() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Tank* temp = _impl_.tank_;
  _impl_.tank_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::Tank* Player::unsafe_arena_release_tank() {
  // @@protoc_insertion_point(field_release:A0S_proto.Player.tank)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Tank* temp = _impl_.tank_;
  _impl_.tank_ = nullptr;
  return temp;
}
inline ::A0S_proto::Tank* Player::_internal_mutable_tank() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tank_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::Tank>(GetArenaForAllocation());
    _impl_.tank_ = p;
  }
  return _impl_.tank_;
}
inline ::A0S_proto::Tank* Player::mutable_tank() {
  ::A0S_proto::Tank* _msg = _internal_mutable_tank();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Player.tank)
  return _msg;
}
inline void Player::set_allocated_tank(::A0S_proto::Tank* tank) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tank_;
  }
  if (tank) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tank);
    if (message_arena != submessage_arena) {
      tank = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tank, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tank_ = tank;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Player.tank)
}

// int32 star_count = 2;
inline void Player::clear_star_count() {
  _impl_.star_count_ = 0;
}
inline ::int32_t Player::star_count() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Player.star_count)
  return _internal_star_count();
}
inline void Player::set_star_count(::int32_t value) {
  _internal_set_star_count(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Player.star_count)
}
inline ::int32_t Player::_internal_star_count() const {
  return _impl_.star_count_;
}
inline void Player::_internal_set_star_count(::int32_t value) {
  ;
  _impl_.star_count_ = value;
}

// int32 fire_time = 3;
inline void Player::clear_fire_time() {
  _impl_.fire_time_ = 0;
}
inline ::int32_t Player::fire_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Player.fire_time)
  return _internal_fire_time();
}
inline void Player::set_fire_time(::int32_t value) {
  _internal_set_fire_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Player.fire_time)
}
inline ::int32_t Player::_internal_fire_time() const {
  return _impl_.fire_time_;
}
inline void Player::_internal_set_fire_time(::int32_t value) {
  ;
  _impl_.fire_time_ = value;
}

// bool movement = 4;
inline void Player::clear_movement() {
  _impl_.movement_ = false;
}
inline bool Player::movement() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Player.movement)
  return _internal_movement();
}
inline void Player::set_movement(bool value) {
  _internal_set_movement(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Player.movement)
}
inline bool Player::_internal_movement() const {
  return _impl_.movement_;
}
inline void Player::_internal_set_movement(bool value) {
  ;
  _impl_.movement_ = value;
}

// bool menu = 5;
inline void Player::clear_menu() {
  _impl_.menu_ = false;
}
inline bool Player::menu() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Player.menu)
  return _internal_menu();
}
inline void Player::set_menu(bool value) {
  _internal_set_menu(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Player.menu)
}
inline bool Player::_internal_menu() const {
  return _impl_.menu_;
}
inline void Player::_internal_set_menu(bool value) {
  ;
  _impl_.menu_ = value;
}

// -------------------------------------------------------------------

// SDL_Point

// int32 x = 1;
inline void SDL_Point::clear_x() {
  _impl_.x_ = 0;
}
inline ::int32_t SDL_Point::x() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Point.x)
  return _internal_x();
}
inline void SDL_Point::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Point.x)
}
inline ::int32_t SDL_Point::_internal_x() const {
  return _impl_.x_;
}
inline void SDL_Point::_internal_set_x(::int32_t value) {
  ;
  _impl_.x_ = value;
}

// int32 y = 2;
inline void SDL_Point::clear_y() {
  _impl_.y_ = 0;
}
inline ::int32_t SDL_Point::y() const {
  // @@protoc_insertion_point(field_get:A0S_proto.SDL_Point.y)
  return _internal_y();
}
inline void SDL_Point::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:A0S_proto.SDL_Point.y)
}
inline ::int32_t SDL_Point::_internal_y() const {
  return _impl_.y_;
}
inline void SDL_Point::_internal_set_y(::int32_t value) {
  ;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Enemy

// .A0S_proto.Tank tank = 1;
inline bool Enemy::has_tank() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tank_ != nullptr);
  return value;
}
inline void Enemy::clear_tank() {
  if (_impl_.tank_ != nullptr) _impl_.tank_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::A0S_proto::Tank& Enemy::_internal_tank() const {
  const ::A0S_proto::Tank* p = _impl_.tank_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::Tank&>(
      ::A0S_proto::_Tank_default_instance_);
}
inline const ::A0S_proto::Tank& Enemy::tank() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.tank)
  return _internal_tank();
}
inline void Enemy::unsafe_arena_set_allocated_tank(
    ::A0S_proto::Tank* tank) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tank_);
  }
  _impl_.tank_ = tank;
  if (tank) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Enemy.tank)
}
inline ::A0S_proto::Tank* Enemy::release_tank() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Tank* temp = _impl_.tank_;
  _impl_.tank_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::Tank* Enemy::unsafe_arena_release_tank() {
  // @@protoc_insertion_point(field_release:A0S_proto.Enemy.tank)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::A0S_proto::Tank* temp = _impl_.tank_;
  _impl_.tank_ = nullptr;
  return temp;
}
inline ::A0S_proto::Tank* Enemy::_internal_mutable_tank() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tank_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::Tank>(GetArenaForAllocation());
    _impl_.tank_ = p;
  }
  return _impl_.tank_;
}
inline ::A0S_proto::Tank* Enemy::mutable_tank() {
  ::A0S_proto::Tank* _msg = _internal_mutable_tank();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Enemy.tank)
  return _msg;
}
inline void Enemy::set_allocated_tank(::A0S_proto::Tank* tank) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tank_;
  }
  if (tank) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tank);
    if (message_arena != submessage_arena) {
      tank = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tank, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tank_ = tank;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Enemy.tank)
}

// uint32 direction_time = 2;
inline void Enemy::clear_direction_time() {
  _impl_.direction_time_ = 0u;
}
inline ::uint32_t Enemy::direction_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.direction_time)
  return _internal_direction_time();
}
inline void Enemy::set_direction_time(::uint32_t value) {
  _internal_set_direction_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.direction_time)
}
inline ::uint32_t Enemy::_internal_direction_time() const {
  return _impl_.direction_time_;
}
inline void Enemy::_internal_set_direction_time(::uint32_t value) {
  ;
  _impl_.direction_time_ = value;
}

// uint32 keep_direction_time = 3;
inline void Enemy::clear_keep_direction_time() {
  _impl_.keep_direction_time_ = 0u;
}
inline ::uint32_t Enemy::keep_direction_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.keep_direction_time)
  return _internal_keep_direction_time();
}
inline void Enemy::set_keep_direction_time(::uint32_t value) {
  _internal_set_keep_direction_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.keep_direction_time)
}
inline ::uint32_t Enemy::_internal_keep_direction_time() const {
  return _impl_.keep_direction_time_;
}
inline void Enemy::_internal_set_keep_direction_time(::uint32_t value) {
  ;
  _impl_.keep_direction_time_ = value;
}

// uint32 speed_time = 4;
inline void Enemy::clear_speed_time() {
  _impl_.speed_time_ = 0u;
}
inline ::uint32_t Enemy::speed_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.speed_time)
  return _internal_speed_time();
}
inline void Enemy::set_speed_time(::uint32_t value) {
  _internal_set_speed_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.speed_time)
}
inline ::uint32_t Enemy::_internal_speed_time() const {
  return _impl_.speed_time_;
}
inline void Enemy::_internal_set_speed_time(::uint32_t value) {
  ;
  _impl_.speed_time_ = value;
}

// uint32 try_to_go_time = 5;
inline void Enemy::clear_try_to_go_time() {
  _impl_.try_to_go_time_ = 0u;
}
inline ::uint32_t Enemy::try_to_go_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.try_to_go_time)
  return _internal_try_to_go_time();
}
inline void Enemy::set_try_to_go_time(::uint32_t value) {
  _internal_set_try_to_go_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.try_to_go_time)
}
inline ::uint32_t Enemy::_internal_try_to_go_time() const {
  return _impl_.try_to_go_time_;
}
inline void Enemy::_internal_set_try_to_go_time(::uint32_t value) {
  ;
  _impl_.try_to_go_time_ = value;
}

// uint32 fire_time = 6;
inline void Enemy::clear_fire_time() {
  _impl_.fire_time_ = 0u;
}
inline ::uint32_t Enemy::fire_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.fire_time)
  return _internal_fire_time();
}
inline void Enemy::set_fire_time(::uint32_t value) {
  _internal_set_fire_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.fire_time)
}
inline ::uint32_t Enemy::_internal_fire_time() const {
  return _impl_.fire_time_;
}
inline void Enemy::_internal_set_fire_time(::uint32_t value) {
  ;
  _impl_.fire_time_ = value;
}

// uint32 reload_time = 7;
inline void Enemy::clear_reload_time() {
  _impl_.reload_time_ = 0u;
}
inline ::uint32_t Enemy::reload_time() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.reload_time)
  return _internal_reload_time();
}
inline void Enemy::set_reload_time(::uint32_t value) {
  _internal_set_reload_time(value);
  // @@protoc_insertion_point(field_set:A0S_proto.Enemy.reload_time)
}
inline ::uint32_t Enemy::_internal_reload_time() const {
  return _impl_.reload_time_;
}
inline void Enemy::_internal_set_reload_time(::uint32_t value) {
  ;
  _impl_.reload_time_ = value;
}

// .A0S_proto.SDL_Point target_position = 8;
inline bool Enemy::has_target_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_position_ != nullptr);
  return value;
}
inline void Enemy::clear_target_position() {
  if (_impl_.target_position_ != nullptr) _impl_.target_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::A0S_proto::SDL_Point& Enemy::_internal_target_position() const {
  const ::A0S_proto::SDL_Point* p = _impl_.target_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::A0S_proto::SDL_Point&>(
      ::A0S_proto::_SDL_Point_default_instance_);
}
inline const ::A0S_proto::SDL_Point& Enemy::target_position() const {
  // @@protoc_insertion_point(field_get:A0S_proto.Enemy.target_position)
  return _internal_target_position();
}
inline void Enemy::unsafe_arena_set_allocated_target_position(
    ::A0S_proto::SDL_Point* target_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_position_);
  }
  _impl_.target_position_ = target_position;
  if (target_position) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:A0S_proto.Enemy.target_position)
}
inline ::A0S_proto::SDL_Point* Enemy::release_target_position() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::A0S_proto::SDL_Point* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::A0S_proto::SDL_Point* Enemy::unsafe_arena_release_target_position() {
  // @@protoc_insertion_point(field_release:A0S_proto.Enemy.target_position)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::A0S_proto::SDL_Point* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
  return temp;
}
inline ::A0S_proto::SDL_Point* Enemy::_internal_mutable_target_position() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::A0S_proto::SDL_Point>(GetArenaForAllocation());
    _impl_.target_position_ = p;
  }
  return _impl_.target_position_;
}
inline ::A0S_proto::SDL_Point* Enemy::mutable_target_position() {
  ::A0S_proto::SDL_Point* _msg = _internal_mutable_target_position();
  // @@protoc_insertion_point(field_mutable:A0S_proto.Enemy.target_position)
  return _msg;
}
inline void Enemy::set_allocated_target_position(::A0S_proto::SDL_Point* target_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_position_;
  }
  if (target_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_position);
    if (message_arena != submessage_arena) {
      target_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.target_position_ = target_position;
  // @@protoc_insertion_point(field_set_allocated:A0S_proto.Enemy.target_position)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace A0S_proto


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::A0S_proto::SpriteType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::A0S_proto::SpriteType>() {
  return ::A0S_proto::SpriteType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_acme_2eproto_2epb_2eh
